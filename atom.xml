<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SmartNi</title>
  <subtitle>code, mylife</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nijun.me/"/>
  <updated>2017-07-15T15:06:33.000Z</updated>
  <id>http://nijun.me/</id>
  
  <author>
    <name>SmartNi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac下配置环境变量不生效问题</title>
    <link href="http://nijun.me/2017/07/15/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <id>http://nijun.me/2017/07/15/Mac下配置环境变量不生效问题/</id>
    <published>2017-07-15T15:00:46.000Z</published>
    <updated>2017-07-15T15:06:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>注意：Mac 下一般使用 bash 作为默认的 shell。</p>
<hr>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>今天在捣鼓 MySQL 的时候，安装删除了好几个循环之后，发现打开 iTerm 之后输入 <code>mysql</code> 不起作用了，刚开始还以为是 MySQL 安装失败了，但是再一次安装成功后还是提示 <code>command not found: mysql</code> 。看到这句话第一时间我就想到了是不是环境变量没有配呢？但是一想不对啊，我之前也是用的好好的也没出现过这个问题啊。</p>
<a id="more"></a>
<p>思路：我们知道 <strong><code>.bash_profile</code></strong> 中是可以设置环境变量的，所以就先从它入手，于是我就往其中添加了下面这句：</p>
<pre><code>export PATH=$PATH:/usr/local/mysql/bin
</code></pre><p>然后保存，输入命令 <strong><code>source ~/.bash_profile</code></strong> ，确实有效！</p>
<p>但是呢，别高兴的太早，作用是有的，但是仅限于当前这个会话。一旦重新开启新的会话，又被打回老样子。</p>
<p>于是我就想，既然 <strong><code>source ~/.bash_profile</code></strong> 这句话能起作用，就不是 <strong><code>.bash_profile</code></strong> 的问题了，那么问题到底出在哪了呢？会不会是系统压根没执行 <strong><code>.bash_profile</code></strong> ？所以我根据系统环境变量的加载顺序，去寻找 <strong><code>/etc</code></strong> 下的两个文件。</p>
<p><strong>profile</strong></p>
<pre><code># System-wide .profile for sh(1)

if [ -x /usr/libexec/path_helper ]; then
    eval `/usr/libexec/path_helper -s`
fi

if [ &quot;${BASH-no}&quot; != &quot;no&quot; ]; then
    [ -r /etc/bashrc ] &amp;&amp; . /etc/bashrc
fi
</code></pre><p>这个文件好像看不出有什么问题。</p>
<p><strong>paths</strong></p>
<pre><code>/usr/local/bin
/usr/bin
/bin
/usr/sbin
/sbin
</code></pre><p>这些是系统默认的环境变量，也找不到什么原因。</p>
<p>然后我新开了一个 Terminal 会话，执行下面查看当前系统环境变量的命令</p>
<pre><code>$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/aria2/bin
</code></pre><p>很奇怪，除了系统默认环境变量之外，还多了 <code>/usr/local/aria2/bin</code> 这个，要知道在我的 ‘.bash_profile’ 中并没有声明这个环境变量。</p>
<p>以上我碰到的问题描述，这个问题花了我一个下午的时间，还好最终是解决了，花了一个晚上写了以下这个总结。</p>
<hr>
<h2 id="一、Mac-系统的环境变量，加载顺序为："><a href="#一、Mac-系统的环境变量，加载顺序为：" class="headerlink" title="一、Mac 系统的环境变量，加载顺序为："></a>一、Mac 系统的环境变量，加载顺序为：</h2><ol>
<li>/etc/profile</li>
<li>/etc/paths</li>
<li>~/.bash_profile</li>
<li>~/.bash_login</li>
<li>~/.profile</li>
<li>~/.bashrc</li>
</ol>
<p>前两个是系统级别的，系统启动就会加载。后面 <strong>3</strong> 个是当前用户级别的环境变量。后面几个按照从前往后的顺序读取，如果 <strong><code>~/.bash_profile</code></strong> 存在，则后面的几个文件就会被忽略不读了，如果 <strong><code>.bash_profile</code></strong> 不存在，才会依次读取垢面的文件。~/.bashrc没有上述规则，它是bash shell打开的时候载入的。</p>
<p>也就是说在当前用户的目录下，如果又了.bash_profile文件就不会去加载.bashrc文件。</p>
<p>所以如果要能正常加载.bashrc文件，需要在.bash_profile文件的最末尾上加入如下语句：</p>
<pre><code class="shell">if [ -f ~/.bashrc ]; then
   source ~/.bashrc
fi
</code></pre>
<h3 id="然而"><a href="#然而" class="headerlink" title="然而"></a>然而</h3><p>如果你没有修改过，上面的方法默认重启后就能生效。</p>
<p>但是，现在的 mac 上有些使用 zsh 这个作为默认的 shell（比如我！！！），所以，在启动 shell 时，默认不会按上面的套路去加载。</p>
<p>如果想要正常加载 <code>.bashrc</code> 文件时，就要找到用户目录下的 <code>.zshrc</code> 文件加入如下代码：</p>
<pre><code>if [ -f ~/.bashrc ]; then
   source ~/.bashrc
fi
</code></pre><p>参考：<a href="http://www.joshstaiger.org/archives/2005/07/bash_profile_vs.html" target="_blank" rel="external">.bash_profile vs .bashrc</a>，建议读一下。</p>
<p>According to the bash man page, .bash_profile is executed for <strong>login</strong> shells, while .bashrc is executed for <strong>interactive non-login</strong> shells.</p>
<hr>
<h2 id="二、设置-PATH-的语法"><a href="#二、设置-PATH-的语法" class="headerlink" title="二、设置 PATH 的语法"></a>二、设置 PATH 的语法</h2><pre><code>//中间用冒号隔开
export PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:......:&lt;PATH N&gt;
</code></pre><h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><p>下面的几个文件设置是全局的，修改时需要 root 权限。</p>
<ol>
<li><code>/etc/paths</code> （全局建议修改这个文件）<br>编辑时一行一个路径。<br>注意：输入环境变量时，不用一个一个输入，只要拖拽文件夹到 Terminal 里就可以了。</li>
<li><code>/etc/profile</code> （建议不修改这个文件）<br>全局（公有）配置，不管是哪个用户，登录时都会读取该文件。</li>
<li><code>/etc/bashrc</code> （一般在这个文件中添加系统级环境变量）<br>全局（公有）配置，<code>bash shell</code> 执行时，不管是何种方式，都会读取此文件。</li>
<li>分模块创建环境变量<ul>
<li>1) 创建一个文件：<pre><code class="shell">$ sudo touch /etc/paths.d/mysql
</code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li>2) 用 vim 打开这个文件（如果是以 open -t 的方式打开，则不允许编辑）：<pre><code class="shell">$ sudo vim /etc/paths.d/mysql
</code></pre>
</li>
<li>3) 编辑该文件，键入路径并保存（关闭该 Terminal 窗口并重新打开一个，就能使用 mysql 命令了）<pre><code>/usr/local/mysql/bin
</code></pre>在我的 ‘/etc/paths.d’ 目录下已经存在了一个文件 <code>aria2c</code> ，这也说了为什么一开始打印系统环境变量时，在最后多出了一个 <code>/usr/local/aria2/bin</code> 目录，因为在我的 <code>.bash_profile</code> 中并没有设置这个路径。顿时豁然开朗，哈哈。</li>
</ul>
<p>还有就是，这样就不用把变量全放在 <code>paths</code> 文件里，方便管理。</p>
<h3 id="单用户设置"><a href="#单用户设置" class="headerlink" title="单用户设置"></a>单用户设置</h3><ol>
<li><strong><code>~/.bash_profile</code></strong> （任意一个文件中添加用户级环境变量）（注：<code>Linux</code> 里面是 <strong><code>.bashrc</code></strong> 而 <code>Mac</code> 是 <code>.bash_profile</code>）<br>若 bash shell 是以 login 方式执行时，才会读取此文件。该文件仅仅执行一次 <strong>1</strong> 默认情况下,它用来设置一些环境变量<br>设置命令别名:<pre><code>alias ll=’ls -la’
</code></pre>设置环境变量:<pre><code>export PATH=/opt/local/bin:/opt/local/sbin:$PATH
</code></pre></li>
</ol>
<h3 id="生效"><a href="#生效" class="headerlink" title="生效"></a>生效</h3><p>如果想要立刻生效，则可以执行下面的语句：</p>
<pre><code class="shell">source ~/.bash_profile
</code></pre>
<p>一般环境变量更改后，重启后生效。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注意：Mac 下一般使用 bash 作为默认的 shell。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;今天在捣鼓 MySQL 的时候，安装删除了好几个循环之后，发现打开 iTerm 之后输入 &lt;code&gt;mysql&lt;/code&gt; 不起作用了，刚开始还以为是 MySQL 安装失败了，但是再一次安装成功后还是提示 &lt;code&gt;command not found: mysql&lt;/code&gt; 。看到这句话第一时间我就想到了是不是环境变量没有配呢？但是一想不对啊，我之前也是用的好好的也没出现过这个问题啊。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="http://nijun.me/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>从头开始之web框架基础</title>
    <link href="http://nijun.me/2017/07/14/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E4%B9%8Bweb%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    <id>http://nijun.me/2017/07/14/从头开始之web框架基础/</id>
    <published>2017-07-14T06:56:18.000Z</published>
    <updated>2017-07-14T13:04:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇包括 Mac 下的 Eclipse 环境搭建，配置 Tomcat 服务器，一个简单的登录页面Demo，包括后台到数据库的一系列逻辑，以及使用到了这几天刚学的 AngularJS 做的页面。</p>
<p>因为 AngularJS4 版本太新了，中文官网没有足够的以 JavaScript 为开发语言的文档，所以先看了AngularJS 2.0之前的文档，先放下以后有时间再看。</p>
<p>从 AngularJS 2 开始官方就推荐使用 TypeScript 。TypeScript是微软开发的开源编程语言，它是JavaScript的一个严格超集，所以任何现有的JavaScript程序都是合法的TypeScript程序。</p>
<p>以下是我学习的资料：</p>
<ol>
<li><a href="https://angular.io/guide/quickstart" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://www.runoob.com/angularjs/angularjs-tutorial.html" target="_blank" rel="external">菜鸟 AngularJS</a> </li>
<li><a href="http://www.runoob.com/angularjs2/angularjs2-tutorial.html" target="_blank" rel="external">菜鸟 AngularJS2</a></li>
<li><a href="http://www.imooc.com/video/4285" target="_blank" rel="external">慕课 AngularJS 实战</a></li>
</ol>
<a id="more"></a>
<h1 id="Eclipse-搭建-Tomcat-环境"><a href="#Eclipse-搭建-Tomcat-环境" class="headerlink" title="Eclipse 搭建 Tomcat 环境"></a>Eclipse 搭建 Tomcat 环境</h1><p>一、下载Eclipse</p>
<p>选择  <a href="https://www.eclipse.org/downloads/eclipse-packages/" target="_blank" rel="external">最新</a>  的版本。注意，选择 <code>Eclipse IDE for Java EE Developers</code> 这个版本，选择好对应的操作系统和位数，然后点击 Download 即可。</p>
<p>二、下载Tomcat</p>
<p>这里，我选择的是 Tomcat 7.0，我们可以根据需要下载适合自己的<a href="https://tomcat.apache.org/" target="_blank" rel="external">版本</a>。</p>
<p>解压缩下载的tomcat文件之后，进入 tomcat 的 <code>bin</code> 目录，使用更改使用权限的命令</p>
<pre><code class="shell"> $ sudo chomd 755 *.sh
</code></pre>
<p>sudo 命令可能会要求输入管理员密码。</p>
<blockquote>
<p>小知识：bin 目录下存在用于启动和停止 tomcat 的许多脚本。Unix下所有需要直接调用的脚本均以 shell 脚本文件（.sh）形式提供，而 windows 系统则以批处理文件（.bat）形式提供</p>
</blockquote>
<p>启动 tomcat</p>
<p>cd 到 tomcat 根目录下，使用如下命令即可启动和关闭</p>
<pre><code class="shell">$ sudo sh startup.sh
$ sudo sh shutdown.sh
</code></pre>
<h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p>创建user表</p>
<p><img src="http://osoa5juml.bkt.clouddn.com//image/site/1500019027922.png" width="651"></p>
<h1 id="创建web工程"><a href="#创建web工程" class="headerlink" title="创建web工程"></a>创建web工程</h1><p>打开 Eclipse，创建 <code>Dynamic web project</code> 项目。</p>
<p>创建 <code>webContent/login.jsp</code> 页面</p>
<p>创建 <code>/src/me/nijun/action/login/LoginAction.java</code> </p>
<h2 id="第一步-创建login-jsp页面"><a href="#第一步-创建login-jsp页面" class="headerlink" title="第一步 创建login.jsp页面"></a>第一步 创建login.jsp页面</h2><pre><code class="html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
         pageEncoding=&quot;UTF-8&quot; %&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html ng-app=&quot;LoginModule&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
    &lt;title&gt;Login&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap-3.0.0/css/bootstrap.css&quot;&gt;
    &lt;script src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js&quot;
            type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/angular-1.3.0.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/form.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;panel panel-primary&quot;&gt;
    &lt;div class=&quot;panel-heading&quot;&gt;
        &lt;div class=&quot;panel-title&quot;&gt;登录&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;panel-body&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div class=&quot;col-md-12&quot;&gt;
                &lt;%--&lt;form class=&quot;form-horizontal&quot; role=&quot;form&quot; ng-submit=&quot;submit()&quot;&gt;--%&gt;
                &lt;form class=&quot;form-horizontal&quot; role=&quot;form&quot; ng-controller=&quot;LoginForm&quot;&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label class=&quot;col-md-2 control-label&quot;&gt;
                            邮箱：
                        &lt;/label&gt;
                        &lt;div class=&quot;col-md-10&quot;&gt;
                            &lt;input type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; class=&quot;form-control&quot;
                                   placeholder=&quot;推荐使用126邮箱&quot; ng-model=&quot;email&quot;&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label class=&quot;col-md-2 control-label&quot;&gt;
                            密码：
                        &lt;/label&gt;
                        &lt;div class=&quot;col-md-10&quot;&gt;
                            &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;
                                   class=&quot;form-control&quot; placeholder=&quot;只能是数字、字母、下划线&quot;
                                   ng-model=&quot;password&quot;&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;div class=&quot;col-md-offset-2 col-md-10&quot;&gt;
                            &lt;div class=&quot;checkbox&quot;&gt;
                                &lt;label&gt;
                                    &lt;input type=&quot;checkbox&quot; ng-model=&quot;autoLogin&quot;&gt;自动登录
                                &lt;/label&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;div class=&quot;col-md-offset-2 col-md-10&quot;&gt;
                            &lt;button class=&quot;btn btn-default&quot; ng-click=&quot;submit()&quot;&gt;提交&lt;/button&gt;
                            &lt;button class=&quot;btn btn-default&quot; ng-click=&quot;resetInfo()&quot;&gt;重置&lt;/button&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/form&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>引入了 bootstrap 作为样式来源，并且引入 AngularJS 1 版本。</p>
<ol>
<li><code>ng-app=&quot; &quot;</code> 定义 <code>angularJS</code> 的使用范围；</li>
<li><code>ng-init=&quot;变量=值;变量=&#39;值&#39;&quot;</code> 初始化变量的值，有多个变量时，中间用分号隔开；</li>
<li><code>ng-model=&quot;变量&quot;</code> 定义变量名；</li>
<li><code>ng-bind=&quot;变量&quot;</code> 绑定变量名，获取该变量的数据。这里的变量就是第3条的变量名。但是一般都用双重花括号来获取变量的值，比如：。</li>
<li><code>ng-model</code>是用于表单元素的，支持双向绑定。对普通元素无效；</li>
<li><code>ng-bind</code>用于普通元素，不能用于表单元素，应用程序单向地渲染数据到元素；</li>
<li>当 <code>ng-bind</code> 和 <code>{ { } }</code>同时使用时，<code>ng-bind</code> 绑定的值覆盖该元素的内容。</li>
</ol>
<p>具体请参见<a href="https://angular.io/guide/quickstart" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="第二步-提交表单信息到servlet"><a href="#第二步-提交表单信息到servlet" class="headerlink" title="第二步 提交表单信息到servlet"></a>第二步 提交表单信息到servlet</h2><p>创建模块</p>
<pre><code class="javascript">var loginModule = angular.module(&#39;LoginModule&#39;, []);
</code></pre>
<p>添加控制器</p>
<pre><code class="javascript">loginModule.controller(&#39;LoginForm&#39;, [&quot;$scope&quot;,&quot;$http&quot;,func]);
</code></pre>
<p>func函数</p>
<pre><code class="javascript">function func($scope,$http) {
        //初始化表单信息
        $scope.email = &quot;nijun717@gmail.com&quot;,
        $scope.password = &quot;123456&quot;,
        $scope.autoLogin = false
        //重置表单函数
        $scope.resetInfo = function(){
                $scope.email = &quot;&quot;,
                $scope.password = &quot;&quot;,
                $scope.autoLogin = false
        },
        //提交表单函数
        $scope.submit = function(){
            var postData = {
                email:$scope.email,
                password:$scope.password,
                autoLogin:$scope.autoLogin
            };

          // $http请求servlet...
        }
    }
</code></pre>
<p>其中 <code>$scope.submit</code> 函数在 <code>jsp</code> 中的提交按钮 <code>ng-click=&quot;submit()&quot;</code> 中被调用。最为关键的使用 <code>$http</code> 请求 <code>servlet</code> 代码如下：</p>
<pre><code class="javascript">//方式一
$http({
    method  : &#39;POST&#39;,
    url     : &#39;loginAction.do&#39;,
    data    : $.param(postData),  // pass in data as strings
    headers : { &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39; }  // set the headers so angular passing info as form data (not request payload)
}).then(function(response){
    console.log(response.config);//请求信息
    console.log(response.config.data);//请求字段
    console.log(response.data.code);
    if (response.data.code == 0){
        window.location.href = &quot;/success.jsp&quot;;
    }
},function(response){

});

//方式二
$http({
    method  : &#39;POST&#39;,
    url     : &#39;loginAction.do&#39;,
    data    : $.param(postData),  // pass in data as strings
    headers : { &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39; } 
}).success(function(data){
    console.log(data);
    if (data.code == 0){
        window.location.href=&quot;/success.jsp&quot;;
    }
});
</code></pre>
<blockquote>
<p>注意，这里有一个坑，当我们在页面中使用 ajax 来异步调用 controller （这里就是servlet）时，这时候页面跳转的函数就不会生效了。包括 forward() 和 sendRedirect() 两个方法。而且我们想要跳转的页面会被当做返回值来返回。这个问题怎么解决呢？</p>
</blockquote>
<p>其实 ajax 在调用 controller 之后会自动返回到上面代码<code>方式二</code>的 success 函数位置，<strong>因此，若我们直接在 controller 中进行页面跳转，则目标页面的源代码会被返回到这个 success 函数里</strong>，正确的页面跳转方式应该是在 success 函数中完成，如上面代码中的：</p>
<pre><code class="javascript">window.location.href=&quot;anotherAction.do&quot;;  
//这行代码中的href值是另一个controller的名字，通过另一个controller跳转到另一个页面。当然也可以直接使用 html 或者 jsp 页面
</code></pre>
<p>为此，我总结一下：$http 是 ajax 的封装，是用来与服务器交互获取 json 数据的，其实就是异步调用，因此在服务器不能直接进行页面的跳转与转发，服务器处理表单数据后将所需的 json 信息返回给客户端中的 success 函数，我们在这个函数里再处理是否要进行页面跳转。</p>
<h2 id="第三步-创建-Controller"><a href="#第三步-创建-Controller" class="headerlink" title="第三步 创建 Controller"></a>第三步 创建 Controller</h2><p>创建 <code>LoginAction.java</code> 继承 <code>HttpServlet</code>，然后在 <code>web.xml</code> 中配置servlet和servlet映射的URL路径。web.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;

    &lt;display-name&gt;SimpleWebDemo&lt;/display-name&gt;
    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;LoginAction&lt;/servlet-name&gt;
        &lt;servlet-class&gt;me.nijun.action.login.LoginAction&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;LoginAction&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/loginAction.do&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<p>覆盖HttpServlet中的doPost()和doGet()方法，一般在doPost()中调用doGet()方法。</p>
<pre><code class="java">@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    System.out.println(&quot;servlet doPost.&quot;);
    doGet(request,response);
    String email = (String) request.getParameter(&quot;email&quot;);
    String password = (String) request.getParameter(&quot;password&quot;);

    PrintWriter writer = response.getWriter();
    JSONObject jsonObject = new JSONObject();

    if (EMAIL.equals(email) &amp;&amp; PASSWORD.equals(password)) {
        jsonObject.put(&quot;code&quot;, 0);
    } else {
        jsonObject.put(&quot;code&quot;, 1);
    }

    writer.print(jsonObject);
    writer.flush();
    writer.close();
}
</code></pre>
<h2 id="第四步-访问数据库"><a href="#第四步-访问数据库" class="headerlink" title="第四步 访问数据库"></a>第四步 访问数据库</h2><p>使用传统的JDBC方式来访问数据库，首先导入 <code>mysql-connector-java-5.0.8-bin.jar</code> 连接mysql的核心jar包。</p>
<h3 id="编写实体类"><a href="#编写实体类" class="headerlink" title="编写实体类"></a>编写实体类</h3><pre><code class="java">package me.nijun.domain;

/**
 * Created by nimon on 2017/7/13.
 */
public class User {

    private  int id;
    private  String email;
    private String password;

    public User(){}

    public User(String email, String password) {
        this.email = email;
        this.password = password;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
</code></pre>
<h3 id="连接的获取和释放"><a href="#连接的获取和释放" class="headerlink" title="连接的获取和释放"></a>连接的获取和释放</h3><p>采用单例模式，driver、url的格式可以参考 <a href="">xxxx</a>。</p>
<pre><code class="java">/**
 * Created by nimon on 2017/7/13.
 * 实现了单例模式的JDBC连接数据库的工具类.
 */
public final class JDBCUtilSingleton {

    static String driver = &quot;com.mysql.jdbc.Driver&quot;;
    String url = &quot;jdbc:mysql://localhost:3306/smartni&quot;;
    String username = &quot;root&quot;;
    String password = &quot;123&quot;;
    Connection connection = null;

    private static JDBCUtilSingleton instance = null;

    //私有构造
    public JDBCUtilSingleton() {

    }

    //并发  加锁
    public static JDBCUtilSingleton getInstance() {
        if (instance == null) {
            synchronized (JDBCUtilSingleton.class) {
                if (instance == null) {
                    instance = new JDBCUtilSingleton();
                }
            }
        }
        return instance;
    }

    //加载JVM时只创建一次连接
    static {
        try {
            Class.forName(driver);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
    //获取连接
    public Connection getConnection() throws SQLException {
        return (Connection) DriverManager.getConnection(url, username, password);
    }

    //规范释放资源方法
    public void Free(ResultSet rs, Statement stmt, Connection conn){
        try{
            if(rs != null){
                rs.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try{
                if(stmt != null){
                    stmt.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }finally {
                try{
                    if(conn != null){
                        conn.close();
                    }
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<h3 id="定义dao接口"><a href="#定义dao接口" class="headerlink" title="定义dao接口"></a>定义dao接口</h3><p>UserDao.java</p>
<pre><code class="java">public interface UserDao {

    /**
     * 添加一个用户
     * @param user 需要添加到数据库的用户对象
     * @return 影响的行数
     * @throws DaoException
     */
    public int addUser(User user) throws DaoException;

    /**
     * 得到一个用户
     * @param username 得到用户所需要的用户名字段
     * @return 得到的用户对象
     * @throws DaoException
     */
    public User findUser(String username) throws DaoException;

}
</code></pre>
<h3 id="实现dao接口的实现类"><a href="#实现dao接口的实现类" class="headerlink" title="实现dao接口的实现类"></a>实现dao接口的实现类</h3><p>UserDaoImpl.java</p>
<pre><code class="java">public class UserDaoImpl implements UserDao {

    JDBCUtilSingleton instance = JDBCUtilSingleton.getInstance();

    @Override
    public int addUser(User user) throws DaoException {
        Connection conn = null;
        PreparedStatement stmt = null;
        ResultSet set = null;
        int res = 0;
        try {
            conn = instance.getConnection();
            //防止sql注入
            String sql = &quot;insert into user values(null,? ,? ,?)&quot;;
            stmt = conn.prepareStatement(sql);
            //设置不自动提交
            conn.setAutoCommit(false);
            stmt.setString(1, user.getUsername());
            stmt.setString(2, user.getEmail());
            stmt.setString(3, user.getPassword());
            res = stmt.executeUpdate();

            System.out.println(&quot;插入记录数: &quot; + res + &quot;条.&quot;);
            conn.setAutoCommit(true);
            return res;
        } catch (SQLException e) {
            throw new DaoException(e.getMessage(), e);
        } finally {
            instance.Free(set,stmt,conn);
            return res;
        }
    }

    @Override
    public User findUser(String username) throws DaoException {
        Connection conn = null;
        PreparedStatement stmt = null;
        ResultSet set = null;
        User user = new User();
        try {
            conn = instance.getConnection();

            String sql = &quot;select id,username,email,password from user where username = ?&quot;;
            stmt = conn.prepareStatement(sql);
            stmt.setString(1, username);
            set = stmt.executeQuery();
            //将指针移动到第一条记录之后
            if (set.next()) {
                user.setId(set.getInt(1));
                user.setUsername(set.getString(2));
                user.setEmail(set.getString(3));
                user.setPassword(set.getString(4));
            }
        } catch (SQLException e) {
            throw new DaoException(e.getMessage(), e);
        } finally {
            instance.Free(set,stmt,conn);
        }
        return user;
    }

}
</code></pre>
<p><code>PreparedStatement.executeQuery();</code> </p>
<p>执行完成之后获得的 <code>ResultSet</code> 对象， <code>ResultSet</code>  是一个接口，¢在获取内容时需要先调用 <code>next()</code> 方法，将读取的指针移动到需要读取的记录的后面，这样才可以获取到数据，这有点类似于LinkedList中的Iterator迭代器。最近也在重新复习这块，以后整理一篇Java集合框架的笔记。</p>
<h3 id="测试-Dao"><a href="#测试-Dao" class="headerlink" title="测试 Dao"></a>测试 Dao</h3><p>UserDaoImplTest.java</p>
<pre><code class="java">public class UserDaoImplTest {

    UserDao ud = new UserDaoImpl();
    @Test
    public void addUser() throws Exception {
        User user = new User();
        user.setUsername(&quot;SmartNi&quot;);
        user.setEmail(&quot;nijun717@gmail.com&quot;);
        user.setPassword(&quot;123456&quot;);

        ud.addUser(user);
    }

    @Test
    public void findUser() throws Exception {
        User user = ud.findUser(&quot;SmartNi&quot;);
        System.out.println(user);
    }

    @Test
    public void testSplit() {
        String text = &quot;f:/jsp:sad&quot;;
        String[] split = text.split(&quot;:&quot;);
        for (String s : split){
            System.out.println(s);
        }
    }
}
</code></pre>
<h3 id="自定义异常，继承-RuntimeException-，具体操作由父类实现。"><a href="#自定义异常，继承-RuntimeException-，具体操作由父类实现。" class="headerlink" title="自定义异常，继承 RuntimeException ，具体操作由父类实现。"></a>自定义异常，继承 RuntimeException ，具体操作由父类实现。</h3><pre><code class="java">public class DaoException extends  Exception {

    public DaoException() {
    }

    public DaoException(String message) {
        super(message);
    }

    public DaoException(String message, Throwable cause) {
        super(message, cause);
    }

    public DaoException(Throwable cause){
        super(cause);
    }
}
</code></pre>
<h3 id="定义Service接口"><a href="#定义Service接口" class="headerlink" title="定义Service接口"></a>定义Service接口</h3><p>UserService.java</p>
<pre><code class="java">public interface UserService {
    /**
     * 获取用户名对应的用户对象
     * @param username 得到用户所需要的用户名字段
     * @return 得到的用户对象
     * @throws DaoException
     */
    public User login(String username) throws ServiceException;


    /**
     * 添加用户的服务
     * @param user 需要添加到数据库的用户对象
     * @return 影响的行数
     * @throws ServiceException
     */
    public int add(User user) throws ServiceException;
}
</code></pre>
<h3 id="实现-Service-接口"><a href="#实现-Service-接口" class="headerlink" title="实现 Service 接口"></a>实现 Service 接口</h3><p>UserServiceImpl.java</p>
<pre><code class="java">public class UserServiceImpl implements UserService {

    UserDao ud = new UserDaoImpl();

    @Override
    public User login(String username) throws ServiceException {
        try {
            return ud.findUser(username);
        } catch (DaoException e) {
            e.printStackTrace();
            throw new ServiceException(e.getMessage(), e);
        }
    }

    @Override
    public int add(User user) throws ServiceException {
        try {
            return ud.addUser(user);
        } catch (DaoException e) {
            e.printStackTrace();
            throw new ServiceException(e.getMessage(), e);
        }
    }
}
</code></pre>
<h1 id="有个想法"><a href="#有个想法" class="headerlink" title="有个想法"></a>有个想法</h1><p>因为，这个例子中我用了 AngularJS ，使用到了 $http 异步来发送表单提交请求，页面的跳转必须还得由客户端根据服务端传来的信息做判断再进场跳转。</p>
<p>还有一点，我这里将登录的逻辑放在了doPost()中，但是 <code>UserAction</code> 类将来必定不只是处理登录操作，还有登出、注册等等操作，不可能将所有操作都放在 <code>doPost()</code> 方法中，所以我的解决办法是：</p>
<ol>
<li>每个请求操作对应一个方法。</li>
<li>根据客户端传递过来的 method 字段判断调用哪个方法。</li>
</ol>
<p>我们来看看改进后的 <code>doPost()</code> </p>
<pre><code class="java">    @Override
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println(&quot;servlet doPost.&quot;);
        doGet(request,response);

        String method = request.getParameter(&quot;method&quot;);
        //判断请求的是什么方法
        if(&quot;login&quot;.equals(method)){
            login(request,response);
        }
        //...未来有更多的方法
    }
</code></pre>
<p>但是，有没有发现，我们每新增一个方法，就需要手动在这里多写一个判断语句。运用反射机制就可以解决这个问题。</p>
<p>BaseAction.java</p>
<pre><code class="java">/**
 * Created by nimon on 2017/7/14.
 * 功能: 执行指定方法, 方便跳转页面
 */
public class BaseAction extends HttpServlet {

    /**
     *
     * @param req
     * @param resp
     * @throws ServletException
     * @throws IOException
     */
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.service(req, resp);
        /*
        得到方法名
         */
        String methodName = req.getParameter(&quot;method&quot;);

        System.out.println(&quot;BaAction : 方法名 : &quot; + methodName);
        if (methodName == null || methodName.trim().isEmpty()) {
            throw new RuntimeException(&quot;您没有传递需要调用的method方法参数,没有调用方法.&quot;);
        }
        /*
        通过反射得到方法
         */
        Class c = this.getClass();
        Method method = null;
        try {
            method = c.getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new RuntimeException(&quot;没有找到你需要调用的方法.&quot;);
        }
        /*
        调用method表示的方法
         */
        try {
            String result = (String) method.invoke(this, req, resp);

            /*
            如果用户返回 null 或者返回空字符串,就什么也不做.
             */
            if (result == null || result.trim().isEmpty()) {
                return;
            }

            /*
            1. 约定返回的字符串中没有包含 &quot;:&quot; ,就说明是转发操作.
            2. 如果包含 &quot;:&quot; ,分为下面两种情况:
                1). 前缀 f 表示转发.
                2). 前缀 r 表示重定向.
             */
            if (result.contains(&quot;:&quot;)) {
                String[] split = result.split(&quot;:&quot;);
                if (split[0].equalsIgnoreCase(&quot;r&quot;)) {
                    req.getRequestDispatcher(split[1]).forward(req, resp);
                } else if (split[0].equalsIgnoreCase(&quot;f&quot;)) {
                    resp.sendRedirect(split[1]);
                } else {
                    throw new RuntimeException(&quot;您请求的地址,当前还不支持.&quot;);
                }
            }else{
                req.getRequestDispatcher(result).forward(req, resp);
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println(&quot;您调用的方法--&quot; + methodName + &quot;--它内部抛出了异常.&quot;);
            throw new RuntimeException();
        }
    }
}
</code></pre>
<p>只要让其他 <code>Servlet</code> 继承这个 <code>BaseAction</code>，然后在自定义方法中返回约定的字符串，即可实现页面跳转。其实这个想法是根据 Strust2 的设计思路来实现的。</p>
<h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p>见我的另一篇文章 <a href="">xxx</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇包括 Mac 下的 Eclipse 环境搭建，配置 Tomcat 服务器，一个简单的登录页面Demo，包括后台到数据库的一系列逻辑，以及使用到了这几天刚学的 AngularJS 做的页面。&lt;/p&gt;
&lt;p&gt;因为 AngularJS4 版本太新了，中文官网没有足够的以 JavaScript 为开发语言的文档，所以先看了AngularJS 2.0之前的文档，先放下以后有时间再看。&lt;/p&gt;
&lt;p&gt;从 AngularJS 2 开始官方就推荐使用 TypeScript 。TypeScript是微软开发的开源编程语言，它是JavaScript的一个严格超集，所以任何现有的JavaScript程序都是合法的TypeScript程序。&lt;/p&gt;
&lt;p&gt;以下是我学习的资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://angular.io/guide/quickstart&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.runoob.com/angularjs/angularjs-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;菜鸟 AngularJS&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.runoob.com/angularjs2/angularjs2-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;菜鸟 AngularJS2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.imooc.com/video/4285&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;慕课 AngularJS 实战&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JSP" scheme="http://nijun.me/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>1000行Mysql学习笔记</title>
    <link href="http://nijun.me/2017/07/13/1000%E8%A1%8CMysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://nijun.me/2017/07/13/1000行Mysql学习笔记/</id>
    <published>2017-07-13T14:57:33.000Z</published>
    <updated>2017-07-15T04:46:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>这篇是从 <a href="http://www.cnblogs.com/shockerli/" target="_blank" rel="external">shockerli</a> 博客园中转载而来 <a href="http://www.cnblogs.com/shockerli/p/1000-plus-line-mysql-notes.html" target="_blank" rel="external">1000行Mysql学习笔记</a>。</p>
<p>满满的都是干货。感觉不错，先保存下，跟着自己敲一遍，再整理一篇自己的学习笔记。</p>
<p>还有一篇自己写的 <a href="">《Mac下Mysql 5.7安装与配置》</a></p>
<a id="more"></a>
<pre><code class="sql">/* Windows下启动MySQL */
net start mysql

/* Mac下启动MySQL */


/* 连接与断开服务器 */
mysql -h 地址 -P 端口 -u 用户名 -p 密码

/* 跳过权限验证登录MySQL */
mysqld --skip-grant-tables
-- 修改root密码
密码加密函数password()
update mysql.user set password=password(&#39;root&#39;);

SHOW PROCESSLIST -- 显示哪些线程正在运行
SHOW VARIABLES -- 

/* 数据库操作 */ ------------------
-- 查看当前数据库
    select database();
-- 显示当前时间、用户名、数据库版本
    select now(), user(), version();
-- 创建库
    create database[ if not exists] 数据库名 数据库选项
    数据库选项：
        CHARACTER SET charset_name
        COLLATE collation_name
-- 查看已有库
    show databases[ like &#39;pattern&#39;]
-- 查看当前库信息
    show create database 数据库名
-- 修改库的选项信息
    alter database 库名 选项信息
-- 删除库
    drop database[ if exists] 数据库名
        同时删除该数据库相关的目录及其目录内容

/* 表的操作 */ ------------------
-- 创建表
    create [temporary] table[ if not exists] [库名.]表名 ( 表的结构定义 )[ 表选项]
        每个字段必须有数据类型
        最后一个字段后不能有逗号
        temporary 临时表，会话结束时表自动消失
        对于字段的定义：
            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#39;string&#39;]
-- 表选项
    -- 字符集
        CHARSET = charset_name
        如果表没有设定，则使用数据库字符集
    -- 存储引擎
        ENGINE = engine_name    
        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同
        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive
        不同的引擎在保存表的结构和数据时采用不同的方式
        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引
        InnoDB表文件含义：.frm表定义，表空间数据和日志文件
        SHOW ENGINES -- 显示存储引擎的状态信息
        SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息
    -- 数据文件目录
        DATA DIRECTORY = &#39;目录&#39;
    -- 索引文件目录
        INDEX DIRECTORY = &#39;目录&#39;
    -- 表注释
        COMMENT = &#39;string&#39;
    -- 分区选项
        PARTITION BY ... (详细见手册)
-- 查看所有表
    SHOW TABLES[ LIKE &#39;pattern&#39;]
    SHOW TABLES FROM 表名
-- 查看表机构
    SHOW CREATE TABLE 表名    （信息更详细）
    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#39;PATTERN&#39;]
    SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;]
-- 修改表
    -- 修改表本身的选项
        ALTER TABLE 表名 表的选项
        EG:    ALTER TABLE 表名 ENGINE=MYISAM;
    -- 对表进行重命名
        RENAME TABLE 原表名 TO 新表名
        RENAME TABLE 原表名 TO 库名.表名    （可将表移动到另一个数据库）
        -- RENAME可以交换两个表名
    -- 修改表的字段机构
        ALTER TABLE 表名 操作名
        -- 操作名
            ADD[ COLUMN] 字段名        -- 增加字段
                AFTER 字段名            -- 表示增加在该字段名后面
                FIRST                -- 表示增加在第一个
            ADD PRIMARY KEY(字段名)    -- 创建主键
            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引
            ADD INDEX [索引名] (字段名)    -- 创建普通索引
            ADD 
            DROP[ COLUMN] 字段名        -- 删除字段
            MODIFY[ COLUMN] 字段名 字段属性        -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)
            CHANGE[ COLUMN] 原字段名 新字段名 字段属性        -- 支持对字段名修改
            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)
            DROP INDEX 索引名    -- 删除索引
            DROP FOREIGN KEY 外键    -- 删除外键

-- 删除表
    DROP TABLE[ IF EXISTS] 表名 ...
-- 清空表数据
    TRUNCATE [TABLE] 表名
-- 复制表结构
    CREATE TABLE 表名 LIKE 要复制的表名
-- 复制表结构和数据
    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名
-- 检查表是否有错误
    CHECK TABLE tbl_name [, tbl_name] ... [option] ...
-- 优化表
    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
-- 修复表
    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]
-- 分析表
    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...



/* 数据操作 */ ------------------
-- 增
    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]
        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。
        -- 可同时插入多条数据记录！
        REPLACE 与 INSERT 完全一样，可互换。
    INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]
-- 查
    SELECT 字段列表 FROM 表名[ 其他子句]
        -- 可来自多个表的多个字段
        -- 其他子句可以不使用
        -- 字段列表可以用*代替，表示所有字段
-- 删
    DELETE FROM 表名[ 删除条件子句]
        没有条件子句，则会删除全部
-- 改
    UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]

/* 字符集编码 */ ------------------
-- MySQL、数据库、表、字段均可设置编码
-- 数据编码与客户端编码不需一致
SHOW VARIABLES LIKE &#39;character_set_%&#39;    -- 查看所有字符集编码项
    character_set_client        客户端向服务器发送数据时使用的编码
    character_set_results        服务器端将结果返回给客户端所使用的编码
    character_set_connection    连接层编码
SET 变量名 = 变量值
    set character_set_client = gbk;
    set character_set_results = gbk;
    set character_set_connection = gbk;
SET NAMES GBK;    -- 相当于完成以上三个设置
-- 校对集
    校对集用以排序
    SHOW CHARACTER SET [LIKE &#39;pattern&#39;]/SHOW CHARSET [LIKE &#39;pattern&#39;]    查看所有字符集
    SHOW COLLATION [LIKE &#39;pattern&#39;]        查看所有校对集
    charset 字符集编码        设置字符集编码
    collate 校对集编码        设置校对集编码

/* 数据类型（列类型） */ ------------------
1. 数值类型
-- a. 整型 ----------
    类型            字节        范围（有符号位）
    tinyint        1字节    -128 ~ 127        无符号位：0 ~ 255
    smallint    2字节    -32768 ~ 32767
    mediumint    3字节    -8388608 ~ 8388607
    int            4字节
    bigint        8字节

    int(M)    M表示总位数
    - 默认存在符号位，unsigned 属性修改
    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改
        例：int(5)    插入一个数&#39;123&#39;，补填后为&#39;00123&#39;
    - 在满足要求的情况下，越小越好。
    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。

-- b. 浮点型 ----------
    类型                字节        范围
    float(单精度)        4字节
    double(双精度)    8字节
    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。
        不同于整型，前后均会补填0.
    定义浮点型时，需指定总位数和小数位数。
        float(M, D)        double(M, D)
        M表示总位数，D表示小数位数。
        M和D的大小会决定浮点数的范围。不同于整型的固定范围。
        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。
        支持科学计数法表示。
        浮点数表示近似值。

-- c. 定点数 ----------
    decimal    -- 可变长度
    decimal(M, D)    M也表示总位数，D表示小数位数。
    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。
    将浮点数转换为字符串来保存，每9位数字保存为4个字节。

2. 字符串类型
-- a. char, varchar ----------
    char    定长字符串，速度快，但浪费空间
    varchar    变长字符串，速度慢，但节省空间
    M表示能存储的最大长度，此长度是字符数，非字节数。
    不同的编码，所占用的空间不同。
    char,最多255个字符，与编码无关。
    varchar,最多65535字符，与编码有关。
    一条有效记录最大不能超过65535个字节。
        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符
    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。
    varchar 的最大有效长度由最大行大小和使用的字符集确定。
    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。
    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3

-- b. blob, text ----------
    blob 二进制字符串（字节字符串）
        tinyblob, blob, mediumblob, longblob
    text 非二进制字符串（字符字符串）
        tinytext, text, mediumtext, longtext
    text 在定义时，不需要定义长度，也不会计算总长度。
    text 类型在定义时，不可给default值

-- c. binary, varbinary ----------
    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。
    char, varchar, text 对应 binary, varbinary, blob.

3. 日期时间类型
    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。
    datetime    8字节    日期及时间        1000-01-01 00:00:00 到 9999-12-31 23:59:59
    date        3字节    日期            1000-01-01 到 9999-12-31
    timestamp    4字节    时间戳        19700101000000 到 2038-01-19 03:14:07
    time        3字节    时间            -838:59:59 到 838:59:59
    year        1字节    年份            1901 - 2155

datetime    “YYYY-MM-DD hh:mm:ss”
timestamp    “YY-MM-DD hh:mm:ss”
            “YYYYMMDDhhmmss”
            “YYMMDDhhmmss”
            YYYYMMDDhhmmss
            YYMMDDhhmmss
date        “YYYY-MM-DD”
            “YY-MM-DD”
            “YYYYMMDD”
            “YYMMDD”
            YYYYMMDD
            YYMMDD
time        “hh:mm:ss”
            “hhmmss”
            hhmmss
year        “YYYY”
            “YY”
            YYYY
            YY

4. 枚举和集合
-- 枚举(enum) ----------
enum(val1, val2, val3...)
    在已知的值中进行单选。最大数量为65535.
    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。
    表现为字符串类型，存储却是整型。
    NULL值的索引是NULL。
    空字符串错误值的索引值是0。

-- 集合（set） ----------
set(val1, val2, val3...)
    create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );
    insert into tab values (&#39;男, 女&#39;);
    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。
    当创建表时，SET成员值的尾部空格将自动被删除。

/* 选择类型 */
-- PHP角度
1. 功能满足
2. 存储空间尽量小，处理效率更高
3. 考虑兼容问题

-- IP存储 ----------
1. 只需存储，可用字符串
2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned
    1) PHP函数转换
        ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。
        利用sprintf函数格式化字符串
        sprintf(&quot;%u&quot;, ip2long(&#39;192.168.3.134&#39;));
        然后用long2ip将整型转回IP字符串
    2) MySQL函数转换(无符号整型，UNSIGNED)
        INET_ATON(&#39;127.0.0.1&#39;) 将IP转为整型
        INET_NTOA(2130706433) 将整型转为IP




/* 列属性（列约束） */ ------------------
1. 主键
    - 能唯一标识记录的字段，可以作为主键。
    - 一个表只能有一个主键。
    - 主键具有唯一性。
    - 声明字段时，用 primary key 标识。
        也可以在字段列表之后声明
            例：create table tab ( id int, stu varchar(10), primary key (id));
    - 主键字段的值不能为null。
    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。
        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));

2. unique 唯一索引（唯一约束）
    使得某字段的值也不能重复。

3. null 约束
    null不是数据类型，是列的一个属性。
    表示当前列是否可以为null，表示什么都没有。
    null, 允许为空。默认。
    not null, 不允许为空。
    insert into tab values (null, &#39;val&#39;);
        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null

4. default 默认值属性
    当前字段的默认值。
    insert into tab values (default, &#39;val&#39;);    -- 此时表示强制使用默认值。
    create table tab ( add_time timestamp default current_timestamp );
        -- 表示将当前时间的时间戳设为默认值。
        current_date, current_time

5. auto_increment 自动增长约束
    自动增长必须为索引（主键或unique）
    只能存在一个字段为自动增长。
    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;

6. comment 注释
    例：create table tab ( id int ) comment &#39;注释内容&#39;;

7. foreign key 外键约束
    用于限制主表与从表数据完整性。
    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);
        -- 将表t1的t1_id外键关联到表t2的id字段。
        -- 每个外键都有一个名字，可以通过 constraint 指定

    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。

    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。

    MySQL中，可以对InnoDB引擎使用外键约束：
    语法：
    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]
    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。

    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。
    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：
    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。
    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。
    3. restrict，拒绝父表删除和更新。

    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。


/* 建表规范 */ ------------------
    -- Normal Format, NF
        - 每个表保存一个实体信息
        - 每个具有一个ID字段作为主键
        - ID主键 + 原子表
    -- 1NF, 第一范式
        字段不能再分，就满足第一范式。
    -- 2NF, 第二范式
        满足第一范式的前提下，不能出现部分依赖。
        消除符合主键就可以避免部分依赖。增加单列关键字。
    -- 3NF, 第三范式
        满足第二范式的前提下，不能出现传递依赖。
        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。
        将一个实体信息的数据放在一个表内实现。


/* select */ ------------------

select [all|distinct] select_expr from -&gt; where -&gt; group by [合计函数] -&gt; having -&gt; order by -&gt; limit

a. select_expr
    -- 可以用 * 表示所有字段。
        select * from tb;
    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）
        select stu, 29+25, now() from tb;
    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。
        - 使用 as 关键字，也可省略 as.
        select stu+10 as add10 from tb;

b. from 子句
    用于标识查询来源。
    -- 可以为表起别名。使用as关键字。
        select * from tb1 as tt, tb2 as bb;
    -- from子句后，可以同时出现多个表。
        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。
        select * from tb1, tb2;

c. where 子句
    -- 从from获得的数据源中进行筛选。
    -- 整型1表示真，0表示假。
    -- 表达式由运算符和运算数组成。
        -- 运算数：变量（字段）、值、函数返回值
        -- 运算符：
            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, 
            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor
            is/is not 加上ture/false/unknown，检验某个值的真假
            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较

d. group by 子句, 分组子句
    group by 字段/别名 [排序方式]
    分组后会进行排序。升序：ASC，降序：DESC

    以下[合计函数]需配合 group by 使用：
    count 返回不同的非NULL值数目    count(*)、count(字段)
    sum 求和
    max 求最大值
    min 求最小值
    avg 求平均值
    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。

e. having 子句，条件子句
    与 where 功能、用法相同，执行时机不同。
    where 在开始时执行检测数据，对原数据进行过滤。
    having 对筛选出的结果再次进行过滤。
    having 字段必须是查询出来的，where 字段必须是数据表存在的。
    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。
    where 不可以使用合计函数。一般需用合计函数才会用 having
    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。

f. order by 子句，排序子句
    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...
    升序：ASC，降序：DESC
    支持多个字段的排序。

g. limit 子句，限制结果数量子句
    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。
    limit 起始位置, 获取条数
    省略第一个参数，表示从索引0开始。limit 获取条数

h. distinct, all 选项
    distinct 去除重复记录
    默认为 all, 全部记录


/* UNION */ ------------------
    将多个select查询的结果组合成一个结果集合。
    SELECT ... UNION [ALL|DISTINCT] SELECT ...
    默认 DISTINCT 方式，即所有返回的行都是唯一的
    建议，对每个SELECT查询加上小括号包裹。
    ORDER BY 排序时，需加上 LIMIT 进行结合。
    需要各select查询的字段数量一样。
    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。


/* 子查询 */ ------------------
    - 子查询需用括号包裹。
-- from型
    from后要求是一个表，必须给子查询结果取个别名。
    - 简化每个查询内的条件。
    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。
    - 子查询返回一个表，表型子查询。
    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;
-- where型
    - 子查询返回一个值，标量子查询。
    - 不需要给子查询取别名。
    - where子查询内的表，不能直接用以更新。
    select * from tb where money = (select max(money) from tb);
    -- 列子查询
        如果子查询结果返回的是一列。
        使用 in 或 not in 完成查询
        exists 和 not exists 条件
            如果子查询返回数据，则返回1或0。常用于判断条件。
            select column1 from t1 where exists (select * from t2);
    -- 行子查询
        查询条件是一个行。
        select * from t1 where (id, gender) in (select id, gender from t2);
        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)
        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。

    -- 特殊运算符
    != all()    相当于 not in
    = some()    相当于 in。any 是 some 的别名
    != some()    不等同于 not in，不等于其中某一个。
    all, some 可以配合其他运算符一起使用。


/* 连接查询(join) */ ------------------
    将多个表的字段进行连接，可以指定连接条件。
-- 内连接(inner join)
    - 默认就是内连接，可省略inner。
    - 只有数据存在时才能发送连接。即连接结果不能出现空行。
    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）
    也可用where表示连接条件。
    还有 using, 但需字段名相同。 using(字段名)

    -- 交叉连接 cross join
        即，没有条件的内连接。
        select * from tb1 cross join tb2;
-- 外连接(outer join)
    - 如果数据不存在，也会出现在连接结果中。
    -- 左外连接 left join
        如果数据不存在，左表记录会出现，而右表为null填充
    -- 右外连接 right join
        如果数据不存在，右表记录会出现，而左表为null填充
-- 自然连接(natural join)
    自动判断连接条件完成连接。
    相当于省略了using，会自动查找相同字段名。
    natural join
    natural left join
    natural right join

select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;

/* 导入导出 */ ------------------
select * into outfile 文件地址 [控制格式] from 表名;    -- 导出表数据
load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式];    -- 导入数据
    生成的数据默认的分隔符是制表符
    local未指定，则数据文件必须在服务器上
    replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理
-- 控制格式
fields    控制字段格式
默认：fields terminated by &#39;\t&#39; enclosed by &#39;&#39; escaped by &#39;\\&#39;
    terminated by &#39;string&#39;    -- 终止
    enclosed by &#39;char&#39;        -- 包裹
    escaped by &#39;char&#39;        -- 转义
    -- 示例：
        SELECT a,b,a+b INTO OUTFILE &#39;/tmp/result.text&#39;
        FIELDS TERMINATED BY &#39;,&#39; OPTIONALLY ENCLOSED BY &#39;&quot;&#39;
        LINES TERMINATED BY &#39;\n&#39;
        FROM test_table;
lines    控制行格式
默认：lines terminated by &#39;\n&#39;
    terminated by &#39;string&#39;    -- 终止

/* insert */ ------------------
select语句获得的数据可以用insert插入。

可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。
    或者使用set语法。
    insert into tbl_name set field=value,...；

可以一次性使用多个值，采用(), (), ();的形式。
    insert into tbl_name values (), (), ();

可以在列值指定时，使用表达式。
    insert into tbl_name values (field_value, 10+10, now());
可以使用一个特殊值 default，表示该列使用默认值。
    insert into tbl_name values (field_value, default);

可以通过一个查询的结果，作为需要插入的值。
    insert into tbl_name select ...;

可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。
    insert into tbl_name values/set/select on duplicate key update 字段=值, …;

/* delete */ ------------------
DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count]

按照条件删除

指定删除的最多记录数。Limit

可以通过排序条件删除。order by + limit

支持多表删除，使用类似连接语法。
delete from 需要删除数据多表1，表2 using 表连接操作 条件。

/* truncate */ ------------------
TRUNCATE [TABLE] tbl_name
清空数据
删除重建表

区别：
1，truncate 是删除表再创建，delete 是逐条删除
2，truncate 重置auto_increment的值。而delete不会
3，truncate 不知道删除了几条，而delete知道。
4，当被用于带分区的表时，truncate 会保留分区


/* 备份与还原 */ ------------------
备份，将数据的结构与表内数据保存起来。
利用 mysqldump 指令完成。

-- 导出
1. 导出一张表
　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)
2. 导出多张表
　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)
3. 导出所有表
　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)
4. 导出一个库 
　　mysqldump -u用户名 -p密码 -B 库名 &gt; 文件名(D:/a.sql)

可以-w携带备份条件

-- 导入
1. 在登录mysql的情况下：
　　source  备份文件
2. 在不登录的情况下
　　mysql -u用户名 -p密码 库名 &lt; 备份文件


/* 视图 */ ------------------
什么是视图：
    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。
    视图具有表结构文件，但不存在数据文件。
    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。
    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。

-- 创建视图
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement
    - 视图名必须唯一，同时不能与表重名。
    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。
    - 可以指定视图执行的算法，通过ALGORITHM指定。
    - column_list如果存在，则数目必须等于SELECT语句检索的列数

-- 查看结构
    SHOW CREATE VIEW view_name 

-- 删除视图
    - 删除视图后，数据依然存在。
    - 可同时删除多个视图。
    DROP VIEW [IF EXISTS] view_name ...

-- 修改视图结构
    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。
    ALTER VIEW view_name [(column_list)] AS select_statement

-- 视图作用
    1. 简化业务逻辑
    2. 对客户端隐藏真实的表结构

-- 视图算法(ALGORITHM)
    MERGE        合并
        将视图的查询语句，与外部查询需要先合并再执行！
    TEMPTABLE    临时表
        将视图执行完毕后，形成临时表，再做外层查询！
    UNDEFINED    未定义(默认)，指的是MySQL自主去选择相应的算法。



/* 事务(transaction) */ ------------------
事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 
    - 支持连续SQL的集体成功或集体撤销。
    - 事务是数据库在数据晚自习方面的一个功能。
    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。
    - InnoDB被称为事务安全型引擎。

-- 事务开启
    START TRANSACTION; 或者 BEGIN;
    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。
-- 事务提交
    COMMIT;
-- 事务回滚
    ROLLBACK;
    如果部分操作发生问题，映射到事务开启前。

-- 事务的特性
    1. 原子性（Atomicity）
        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
    2. 一致性（Consistency）
        事务前后数据的完整性必须保持一致。
        - 事务开始和结束时，外部数据一致
        - 在整个事务过程中，操作是连续的
    3. 隔离性（Isolation）
        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。
    4. 持久性（Durability）
        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。

-- 事务的实现
    1. 要求是事务支持的表类型
    2. 执行一组相关的操作前开启事务
    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。

-- 事务的原理
    利用InnoDB的自动提交(autocommit)特性完成。
    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。
    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。

-- 注意
    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。
    2. 事务不能被嵌套

-- 保存点
    SAVEPOINT 保存点名称 -- 设置一个事务保存点
    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点
    RELEASE SAVEPOINT 保存点名称 -- 删除保存点

-- InnoDB自动提交特性设置
    SET autocommit = 0|1;    0表示关闭自动提交，1表示开启自动提交。
    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。
    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，
        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)
        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)


/* 锁表 */
表锁定只用于防止其它客户端进行不正当地读取和写入
MyISAM 支持表锁，InnoDB 支持行锁
-- 锁定
    LOCK TABLES tbl_name [AS alias]
-- 解锁
    UNLOCK TABLES


/* 触发器 */ ------------------
    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象
    监听：记录的增加、修改、删除。

-- 创建触发器
CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt
    参数：
    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。
    trigger_event指明了激活触发程序的语句的类型
        INSERT：将新行插入表时激活触发程序
        UPDATE：更改某一行时激活触发程序
        DELETE：从表中删除某一行时激活触发程序
    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。
    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构

-- 删除
DROP TRIGGER [schema_name.]trigger_name

可以使用old和new代替旧的和新的数据
    更新操作，更新前是old，更新后是new.
    删除操作，只有old.
    增加操作，只有new.

-- 注意
    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。


-- 字符连接函数
concat(str1[, str2,...])

-- 分支语句
if 条件 then
    执行语句
elseif 条件 then
    执行语句
else
    执行语句
end if;

-- 修改最外层语句结束符
delimiter 自定义结束符号
    SQL语句
自定义结束符号

delimiter ;        -- 修改回原来的分号

-- 语句块包裹
begin
    语句块
end

-- 特殊的执行
1. 只要添加记录，就会触发程序。
2. Insert into on duplicate key update 语法会触发：
    如果没有重复记录，会触发 before insert, after insert;
    如果有重复记录并更新，会触发 before insert, before update, after update;
    如果有重复记录但是没有发生更新，则触发 before insert, before update
3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert


/* SQL编程 */ ------------------

--// 局部变量 ----------
-- 变量声明
    declare var_name[,...] type [default value] 
    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。 

-- 赋值
    使用 set 和 select into 语句为变量赋值。

    - 注意：在函数内是可以使用全局变量（用户自定义的变量）


--// 全局变量 ----------
-- 定义、赋值
set 语句可以定义并为变量赋值。
set @var = value;
也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。
还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。
select @var:=20;
select @v1:=id, @v2=name from t1 limit 1;
select * from tbl_name where @var:=30;

select into 可以将表中查询获得的数据赋给变量。
    -| select max(height) into @max_height from tb;

-- 自定义变量名
为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。
@var=10;

    - 变量被定义后，在整个会话周期都有效（登录到退出）


--// 控制结构 ----------
-- if语句
if search_condition then 
    statement_list    
[elseif search_condition then
    statement_list]
...
[else
    statement_list]
end if;

-- case语句
CASE value WHEN [compare-value] THEN result
[WHEN [compare-value] THEN result ...]
[ELSE result]
END


-- while循环
[begin_label:] while search_condition do
    statement_list
end while [end_label];

- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。

    -- 退出循环
        退出整个循环 leave
        退出当前循环 iterate
        通过退出的标签决定退出哪个循环


--// 内置函数 ----------
-- 数值函数
abs(x)            -- 绝对值 abs(-10.9) = 10
format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46
ceil(x)            -- 向上取整 ceil(10.1) = 11
floor(x)        -- 向下取整 floor (10.1) = 10
round(x)        -- 四舍五入去整
mod(m, n)        -- m%n m mod n 求余 10%3=1
pi()            -- 获得圆周率
pow(m, n)        -- m^n
sqrt(x)            -- 算术平方根
rand()            -- 随机数
truncate(x, d)    -- 截取d位小数

-- 时间日期函数
now(), current_timestamp();     -- 当前日期时间
current_date();                    -- 当前日期
current_time();                    -- 当前时间
date(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取日期部分
time(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取时间部分
date_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;);    -- 格式化时间
unix_timestamp();                -- 获得unix时间戳
from_unixtime();                -- 从时间戳获得时间

-- 字符串函数
length(string)            -- string长度，字节
char_length(string)        -- string的字符个数
substring(str, position [,length])        -- 从str的position开始,取length个字符
replace(str ,search_str ,replace_str)    -- 在str中用replace_str替换search_str
instr(string ,substring)    -- 返回substring首次在string中出现的位置
concat(string [,...])    -- 连接字串
charset(str)            -- 返回字串字符集
lcase(string)            -- 转换成小写
left(string, length)    -- 从string2中的左边起取length个字符
load_file(file_name)    -- 从文件读取内容
locate(substring, string [,start_position])    -- 同instr,但可指定开始位置
lpad(string, length, pad)    -- 重复用pad加在string开头,直到字串长度为length
ltrim(string)            -- 去除前端空格
repeat(string, count)    -- 重复count次
rpad(string, length, pad)    --在str后用pad补充,直到长度为length
rtrim(string)            -- 去除后端空格
strcmp(string1 ,string2)    -- 逐字符比较两字串大小

-- 流程函数
case when [condition] then result [when [condition] then result ...] [else result] end   多分支
if(expr1,expr2,expr3)  双分支。

-- 聚合函数
count()
sum();
max();
min();
avg();
group_concat()

-- 其他常用函数
md5();
default();


--// 存储函数，自定义函数 ----------
-- 新建
    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型
        函数体

    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。
    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。
    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。
    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。
    - 多条语句应该使用 begin...end 语句块包含。
    - 一定要有 return 返回值语句。

-- 删除
    DROP FUNCTION [IF EXISTS] function_name;

-- 查看
    SHOW FUNCTION STATUS LIKE &#39;partten&#39;
    SHOW CREATE FUNCTION function_name;

-- 修改
    ALTER FUNCTION function_name 函数选项


--// 存储过程，自定义功能 ----------
-- 定义
存储存储过程 是一段代码（过程），存储在数据库中的sql组成。
一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。
而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。

-- 创建
CREATE PROCEDURE sp_name (参数列表)
    过程体

参数列表：不同于函数的参数列表，需要指明参数类型
IN，表示输入型
OUT，表示输出型
INOUT，表示混合型

注意，没有返回值。


/* 存储过程 */ ------------------
存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。
调用：CALL 过程名
-- 注意
- 没有返回值。
- 只能单独调用，不可夹杂在其他语句中

-- 参数
IN|OUT|INOUT 参数名 数据类型
IN        输入：在调用过程中，将数据输入到过程体内部的参数
OUT        输出：在调用过程中，将过程体处理完的结果返回到客户端
INOUT    输入输出：既可输入，也可输出

-- 语法
CREATE PROCEDURE 过程名 (参数列表)
BEGIN
    过程体
END


/* 用户和权限管理 */ ------------------
用户信息表：mysql.user
-- 刷新权限
FLUSH PRIVILEGES
-- 增加用户
CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)
    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。
    - 只能创建用户，不能赋予权限。
    - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39;
    - 密码也需引号，纯数字密码也要加引号
    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD
-- 重命名用户
RENAME USER old_user TO new_user
-- 设置密码
SET PASSWORD = PASSWORD(&#39;密码&#39;)    -- 为当前用户设置密码
SET PASSWORD FOR 用户名 = PASSWORD(&#39;密码&#39;)    -- 为指定用户设置密码
-- 删除用户
DROP USER 用户名
-- 分配权限/添加用户
GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#39;password&#39;]
    - all privileges 表示所有权限
    - *.* 表示所有库的所有表
    - 库名.表名 表示某库下面的某表
-- 查看权限
SHOW GRANTS FOR 用户名
    -- 查看当前用户权限
    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();
-- 撤消权限
REVOKE 权限列表 ON 表名 FROM 用户名
REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名    -- 撤销所有权限
-- 权限层级
-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。
全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user
    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。
数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host
    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。
表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv
    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。
列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv
    当使用REVOKE时，您必须指定与被授权列相同的列。
-- 权限列表
ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限
ALTER    -- 允许使用ALTER TABLE
ALTER ROUTINE    -- 更改或取消已存储的子程序
CREATE    -- 允许使用CREATE TABLE
CREATE ROUTINE    -- 创建已存储的子程序
CREATE TEMPORARY TABLES        -- 允许使用CREATE TEMPORARY TABLE
CREATE USER        -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。
CREATE VIEW        -- 允许使用CREATE VIEW
DELETE    -- 允许使用DELETE
DROP    -- 允许使用DROP TABLE
EXECUTE        -- 允许用户运行已存储的子程序
FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE
INDEX     -- 允许使用CREATE INDEX和DROP INDEX
INSERT    -- 允许使用INSERT
LOCK TABLES        -- 允许对您拥有SELECT权限的表使用LOCK TABLES
PROCESS     -- 允许使用SHOW FULL PROCESSLIST
REFERENCES    -- 未被实施
RELOAD    -- 允许使用FLUSH
REPLICATION CLIENT    -- 允许用户询问从属服务器或主服务器的地址
REPLICATION SLAVE    -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）
SELECT    -- 允许使用SELECT
SHOW DATABASES    -- 显示所有数据库
SHOW VIEW    -- 允许使用SHOW CREATE VIEW
SHUTDOWN    -- 允许使用mysqladmin shutdown
SUPER    -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。
UPDATE    -- 允许使用UPDATE
USAGE    -- “无权限”的同义词
GRANT OPTION    -- 允许授予权限


/* 表维护 */
-- 分析和存储表的关键字分布
ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...
-- 检查一个或多个表是否有错误
CHECK TABLE tbl_name [, tbl_name] ... [option] ...
option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}
-- 整理数据文件的碎片
OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...


/* 杂项 */ ------------------
1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！
2. 每个库目录存在一个保存当前数据库的选项文件db.opt。
3. 注释：
    单行注释 # 注释内容
    多行注释 /* 注释内容 */
    单行注释 -- 注释内容        (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)
4. 模式通配符：
    _    任意单个字符
    %    任意多个字符，甚至包括零字符
    单引号需要进行转义 \&#39;
5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\G&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。
6. SQL对大小写不敏感
7. 清除已有语句：\c
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;p&gt;这篇是从 &lt;a href=&quot;http://www.cnblogs.com/shockerli/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;shockerli&lt;/a&gt; 博客园中转载而来 &lt;a href=&quot;http://www.cnblogs.com/shockerli/p/1000-plus-line-mysql-notes.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1000行Mysql学习笔记&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;满满的都是干货。感觉不错，先保存下，跟着自己敲一遍，再整理一篇自己的学习笔记。&lt;/p&gt;
&lt;p&gt;还有一篇自己写的 &lt;a href=&quot;&quot;&gt;《Mac下Mysql 5.7安装与配置》&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://nijun.me/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>20个数据库设计的最佳实践</title>
    <link href="http://nijun.me/2017/07/13/00001-Database-2017-07-13-20%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://nijun.me/2017/07/13/00001-Database-2017-07-13-20个数据库设计的最佳实践/</id>
    <published>2017-07-13T12:18:59.000Z</published>
    <updated>2017-07-13T15:04:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据库设计是整个程序的重点之一，为了支持相关程序运行，最佳的数据库设计往往不可能一蹴而就，只能反复探寻并逐步求精，这是一个复杂的过程，也是规划和结构化数据库中的数据对象以及这些数据对象之间关系的过程。下面给出了20个数据库设计最佳实践，当然，所谓最佳，还是要看它是否适合你的程序。一起来了解了解吧。</p>
<p> <img src="http://osoa5juml.bkt.clouddn.com//image/site/1499949068975.gif" alt="img"></p>
<a id="more"></a>
<ol>
<li>使用明确、统一的标明和列名，例如 School, SchoolCourse, CourceID。</li>
<li>数据表名使用单数而不是复数，例如 StudentCourse，而不是 StudentCourses。</li>
<li>数据表名不要使用空格。</li>
<li>数据表名不要使用不必要的前缀或者后缀，例如使用 School，而不是 TblSchool，或者 SchoolTable 等等。</li>
<li>数据库中的密码要加密，到应用中再解密。 （其实就是散列存储、单向加密）</li>
<li>使用整数作为 ID 字段，也许现在没有这个必要，但是将来需要，例如关联表，索引等等。</li>
<li>使用整数字段做索引，否则会带来很大的性能问题 。</li>
<li>使用 bit 作为布尔字段，使用整数或者 varchar 是浪费。同时，这类字段应该以 “Is” 开头。</li>
<li>要经过认证才能访问数据库，不要给每一个用户管理员权限。</li>
<li>尽量避免使用 “select *”，而使用 “select [required_column_list]” 以获得更好的性能。</li>
<li>假如程序代码比较复杂，使用 ORM 框架，例如 hibernate，iBatis。ORM 框架的性能问题可以通过详细的配置去解决。</li>
<li>分割不常使用的数据表到不同的物理存储以获得更好的性能。</li>
<li>对于关键数据库，使用安全备份系统，例如集群，同步等等。</li>
<li>使用外键，非空等限制来保证数据的完整性，不要把所有的东西都扔给程序。</li>
<li>缺乏数据库文档是致命的。你应该为你的数据库设计写文档，包括触发器、存储过程和其他脚本。</li>
<li>对于经常使用的查询和大型数据表，要使用索引。数据分析工具可以帮助你决定如何建立索引。</li>
<li>数据库服务器和网页服务器应该放在不同的机器上。这回提高安全性，并减轻 CPU 压力。</li>
<li>Image 和 blob 字段不应该定义在常用的数据表中，否则会影响性能。</li>
<li>范式（Normalization）要按照要求使用以提高性能。Normalization 做的不够会导致数据冗余，而过度Normalization 会导致太多的 join 和数据表，这两种情况都会影响性能。</li>
<li>多花点时间在数据库设计上，否则你将来会付出加倍的时间来偿还。</li>
</ol>
<p>　　英文原址：<a href="http://www.javacodegeeks.com/2012/02/20-database-design-best-practices.html" target="_blank" rel="external">javacodegeeks.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库设计是整个程序的重点之一，为了支持相关程序运行，最佳的数据库设计往往不可能一蹴而就，只能反复探寻并逐步求精，这是一个复杂的过程，也是规划和结构化数据库中的数据对象以及这些数据对象之间关系的过程。下面给出了20个数据库设计最佳实践，当然，所谓最佳，还是要看它是否适合你的程序。一起来了解了解吧。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://osoa5juml.bkt.clouddn.com//image/site/1499949068975.gif&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://nijun.me/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>简单十步让你全面理解SQL</title>
    <link href="http://nijun.me/2017/07/13/00001-Database-2017-07-13-%E7%AE%80%E5%8D%95%E5%8D%81%E6%AD%A5%E8%AE%A9%E4%BD%A0%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3SQL/"/>
    <id>http://nijun.me/2017/07/13/00001-Database-2017-07-13-简单十步让你全面理解SQL/</id>
    <published>2017-07-13T11:59:05.000Z</published>
    <updated>2017-07-13T15:06:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>声明，本篇转载自 <a href="http://www.cnblogs.com/shockerli/p/10-easy-steps-to-a-complete-understanding-of-sql.html" target="_blank" rel="external">简单十步让你全面理解SQL</a>。第一次看感觉好深，所以转载来慢慢消化。</p>
</blockquote>
<p>很多程序员认为SQL是一头难以驯服的野兽。它是为数不多的声明性语言之一，也因为这样，其展示了完全不同于其他的表现形式、命令式语言、 面向对象语言甚至函数式编程语言（虽然有些人觉得SQL 还是有些类似功能）。</p>
<p>为了向你呈现SQL的优美！下面的教程面向于：</p>
<ul>
<li>已经使用过但没有完全理解SQL的读者</li>
<li>已经差不多了解SQL但从未真正考虑过它的语法的读者</li>
<li>想要指导他人学习SQL的读者</li>
</ul>
<a id="more"></a>
<p> 本教程将重点介绍SELECT 语句。其他 DML 语句将在另一个教程中在做介绍。接下来就是…</p>
<h2 id="1、SQL是声明性语言"><a href="#1、SQL是声明性语言" class="headerlink" title="1、SQL是声明性语言"></a><strong>1、SQL是声明性语言</strong></h2><p> 首先你需要思考的是，声明性。你唯一需要做的只是声明你想获得结果的性质，而不需要考虑你的计算机怎么算出这些结果的。</p>
<pre><code>SELECT first_name, last_name FROM employees WHERE salary &gt; 100000
</code></pre><p> 这很容易理解，你无须关心员工的身份记录从哪来，你只需要知道谁有着不错的薪水。</p>
<p> <strong>从中我们学到了什么呢？</strong></p>
<p> 那么如果它是这样的简单，会出现什么问题吗？问题就是我们大多数人会直观地认为这是命令式编程。如：“机器，做这，再做那，但在这之前，如果这和那都发生错误，那么会运行一个检测”。这包括在变量中存储临时的编写循环、迭代、调用函数，等等结果。</p>
<p> 把那些都忘了吧，想想怎么去声明，而不是怎么告诉机器去计算。</p>
<h2 id="2、SQL语法不是“有序的”"><a href="#2、SQL语法不是“有序的”" class="headerlink" title="2、SQL语法不是“有序的”"></a><strong>2、SQL语法不是“有序的”</strong></h2><p> 常见的混乱源于一个简单的事实，SQL语法元素并不会按照它们的执行方式排序。语法顺序如下：</p>
<ul>
<li>SELECT [DISTINCT]</li>
<li>FROM</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UNION</li>
<li><p>ORDER BY</p>
<p>为简单起见，并没有列出所有SQL语句。这个语法顺序与逻辑顺序基本上不同，执行顺序如下： </p>
</li>
<li><p>FROM</p>
</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>SELECT</li>
<li>DISTINCT</li>
<li>UNION</li>
<li>ORDER BY</li>
</ul>
<h3 id="这有三点需要注意："><a href="#这有三点需要注意：" class="headerlink" title="这有三点需要注意："></a>这有三点需要注意：</h3><p>1、第一句是FROM，而不是SELECT。首先是将数据从磁盘加载到内存中，以便对这些数据进行操作。</p>
<p>2、SELECT是在其他大多数语句后执行，最重要的是，在FROM和GROUP BY之后。重要的是要理解当你觉得你可以从WHERE语句中引用你定义在SELECT语句当中的时候，。以下是不可行的：</p>
<pre><code>SELECT A.x + A.y AS z FROM A WHERE z = 10 -- z is not available here!
</code></pre><p> 如果你想重用z,您有两种选择。要么重复表达式: </p>
<pre><code>SELECT A.x + A.y AS z FROM A WHERE (A.x + A.y) = 10
</code></pre><p> 或者你使用派生表、公用表表达式或视图来避免代码重复。请参阅示例进一步的分析：</p>
<p>3、在语法和逻辑顺序里，UNION都是放在ORDER BY之前，很多人认为每个UNION子查询都可以进行排序，但根据SQL标准和大多数的SQL方言，并不是真的可行。虽然一些方言允许子查询或派生表排序，但却不能保证这种顺序能在UNION操作后保留。</p>
<p> 需要注意的是，并不是所有的数据库都以相同的形式实现，例如规则2并不完全适用于MySQL,PostgreSQL,和SQLite上</p>
<h3 id="从中我们学到了什么呢？"><a href="#从中我们学到了什么呢？" class="headerlink" title="从中我们学到了什么呢？"></a><strong>从中我们学到了什么呢？</strong></h3><p> 要时刻记住SQL语句的语法顺序和逻辑顺序来避免常见的错误。如果你能明白这其中的区别，就能明确知道为什么有些可以执行有些则不能。</p>
<p> 如果能设计一种在语法顺序上实际又体现了逻辑顺序的语言就更好了，因为它是在微软的LINQ上实现的。</p>
<h2 id="3、SQL是关于数据表引用的"><a href="#3、SQL是关于数据表引用的" class="headerlink" title="3、SQL是关于数据表引用的 "></a><strong>3、SQL是关于数据表引用的 </strong></h2><p> 因为语法顺序和逻辑顺序的差异，大多数初学者可能会误认为SQL中列的值是第一重要的。其实并非如此，最重要的是数据表引用。</p>
<p> 该SQL标准定义了FROM语句，如下：</p>
<pre><code>&lt;from clause&gt; ::= FROM &amp;lt;table reference&amp;gt; [ { &amp;lt;comma&amp;gt; &amp;lt;table reference&amp;gt; }... ]
</code></pre><p> ROM语句的”output”是所有表引用的结合程度组合表引用。让我们慢慢地消化这些。 </p>
<pre><code>FROM a, b
</code></pre><p> 上述产生一个a+b度的组合表引用，如果a有3列和b有5列，那么”输出表”将有8（3+5）列。</p>
<p> 包含在这个组合表引用的记录是交叉乘积/笛卡儿积的axb。换句话说，每一条a记录都会与每一条b记录相对应。如果a有3个记录和b有5条记录,然后上面的组合表引用将产生15条记录(3×5)。</p>
<p> 在WHERE语句筛选后，GROUP BY语句中”output”是”fed”/“piped”，它已转成新的”output”，我们会稍后再去处理。</p>
<p> 如果我们从关系代数/集合论的角度来看待这些东西，一个SQL表是一个关系或一组元素组合。每个SQL语句将改变一个或几个关系，来产生新的关系。</p>
<h3 id="从中我们学到了什么呢？-1"><a href="#从中我们学到了什么呢？-1" class="headerlink" title="从中我们学到了什么呢？"></a><strong>从中我们学到了什么呢？</strong></h3><p> 一直从数据表引用角度去思考，有助于理解数据怎样通过你的sql语句流水作业的</p>
<h2 id="4、SQL数据表引用可以相当强大"><a href="#4、SQL数据表引用可以相当强大" class="headerlink" title="4、SQL数据表引用可以相当强大"></a><strong>4、SQL数据表引用可以相当强大</strong></h2><p> 表引用是相当强大的东西。举个简单的例子，JOIN关键字其实不是SELECT语句的一部分，但却是”special”表引用的一部分。连接表，在<a href="http://www.andrew.cmu.edu/user/shadow/sql/sql1992.txt" target="_blank" rel="external">SQL标准</a>中有定义（简化的）：</p>
<pre><code>&lt;table reference&gt; ::=

&lt;table name&gt;

| &lt;derived table&gt;

| &lt;joined table&gt;
</code></pre><p>如果我们又拿之前的例子来分析： </p>
<pre><code>FROM a, b
</code></pre><p> a可以作为一个连接表，如：</p>
<pre><code>a1 JOIN a2 ON a1.id = a2.id
</code></pre><p> 这扩展到前一个表达式，我们会得到：</p>
<pre><code>FROM a1 JOIN a2 ON a1.id = a2.id, b
</code></pre><p> 虽然结合了数据表引用语法与连接表语法的逗号分隔表让人很无语，但你肯定还会这样做的。结果，结合数据表引用将有a1+a2+b度。</p>
<p> 派生表甚至比连接表更强大，我们接下来将会说到。</p>
<h3 id="从中我们学到了什么呢？-2"><a href="#从中我们学到了什么呢？-2" class="headerlink" title="从中我们学到了什么呢？"></a><strong>从中我们学到了什么呢？</strong></h3><p> 要时时刻刻考虑表引用，重要的是这不仅让你理解数据怎样通过你的sql语句流水作业的，它还将帮助你了解复杂表引用是如何构造的。</p>
<p> 而且，重要的是，了解JOIN是构造连接表的关键字。不是的SELECT语句的一部分。某些数据库允许JOIN在插入、更新、删除中使用。</p>
<h2 id="5、应使用SQL-JOIN的表，而不是以逗号分隔表"><a href="#5、应使用SQL-JOIN的表，而不是以逗号分隔表" class="headerlink" title="5、应使用SQL JOIN的表，而不是以逗号分隔表 "></a><strong>5、应使用SQL JOIN的表，而不是以逗号分隔表 </strong></h2><p> 前面，我们已经看到这语句： </p>
<pre><code>FROM a, b
</code></pre><p> 高级SQL开发人员可能会告诉你，最好不要使用逗号分隔的列表，并且一直完整的表达你的JOINs。这将有助于改进你的SQL语句的可读性从而防止错误出现。</p>
<p> 一个非常常见的错误是忘记某处连接谓词。思考以下内容：</p>
<pre><code>FROM a, b, c, d, e, f, g, h WHERE a.a1 = b.bx AND a.a2 = c.c1 AND d.d1 = b.bc -- etc...
</code></pre><p>使用join来查询表的语法</p>
<ul>
<li>更安全，你可以把连接谓词与连接表放一起，从而防止错误。</li>
<li>更富于表现力，你可以区分外部连接，内部连接，等等。​​</li>
</ul>
<h3 id="从中我们学到了什么呢？-3"><a href="#从中我们学到了什么呢？-3" class="headerlink" title="从中我们学到了什么呢？"></a><strong>从中我们学到了什么呢？</strong></h3><p> 使用JOIN，并且永远不在FROM语句中使用逗号分隔表引用。 </p>
<h2 id="6、SQL的不同类型的连接操作"><a href="#6、SQL的不同类型的连接操作" class="headerlink" title="6、SQL的不同类型的连接操作"></a><strong>6、SQL的不同类型的连接操作</strong></h2><p> 连接操作基本上有五种</p>
<ul>
<li>EQUI JOIN</li>
<li>SEMI JOIN</li>
<li>ANTI JOIN</li>
<li>CROSS JOIN</li>
<li><p>DIVISION</p>
<p>这些术语通常用于关系代数。对上述概念，如果他们存在，SQL会使用不同的术语。让我们仔细看看:</p>
</li>
</ul>
<h3 id="EQUI-JOIN（同等连接）"><a href="#EQUI-JOIN（同等连接）" class="headerlink" title=" EQUI JOIN（同等连接）"></a><strong> EQUI JOIN（同等连接）</strong></h3><p> 这是最常见的JOIN操作。它有两个子操作:</p>
<ul>
<li>INNER JOIN(或者只是JOIN)</li>
<li><p>OUTER JOIN(可以再次拆分为LEFT, RIGHT,FULL OUTER JOIN)</p>
<p>例子是其中的区别最好的解释:</p>
</li>
</ul>
<pre><code>-- This table reference contains authors and their books.

-- There is one record for each book and its author.

-- authors without books are NOT included
 author JOIN book ON author.id = book.author_id -- This table reference contains authors and their books

-- There is one record for each book and its author.

-- ... OR there is an &quot;empty&quot; record for authors without books

-- (&quot;empty&quot; meaning that all book columns are NULL)
 author LEFT OUTER JOIN book ON author.id = book.author_id
</code></pre><h3 id="SEMI-JOIN（半连接）"><a href="#SEMI-JOIN（半连接）" class="headerlink" title="SEMI JOIN（半连接）"></a><strong>SEMI JOIN（半连接）</strong></h3><p> 这种关系的概念在SQL中用两种方式表达：使用IN谓词或使用EXISTS谓语。”Semi”是指在拉丁语中的”half”。这种类型的连接用于连接只有”half”的表引用。再次考虑上述加入的作者和书。让我们想象，我们想要作者/书的组合,但只是那些作者实际上也有书。然后我们可以这样写:</p>
<pre><code>-- Using IN

FROM author WHERE author.id IN (SELECT book.author_id FROM book) -- Using EXISTS

FROM author WHERE EXISTS (SELECT 1 FROM book WHERE book.author_id = author.id)
</code></pre><p> 虽然不能肯定你到底是更加喜欢IN还是EXISTS，而且也没有规则说明，但可以这样说：</p>
<ul>
<li>IN往往比EXISTS更具可读性</li>
<li>EXISTS往往比IN更富表现力（如它更容易表达复杂的半连接）</li>
<li><p>一般情况下性能上没有太大的差异，但，在某些数据库可能会有巨大的性能差异。</p>
<p>因为INNER JOIN有可能只产生有书的作者，因为很多初学者可能认为他们可以使用DISTINCT删除重复项。他们认为他们可以表达一个像这样的半联接：</p>
</li>
</ul>
<pre><code>-- Find only those authors who also have books

SELECT DISTINCT first_name, last_name FROM author
</code></pre><p>这是非常不好的做法，原因有二：</p>
<ul>
<li>它非常慢，因为该数据库有很多数据加载到内存中，只是要再删除重复项。</li>
<li><p>它不完全正确，即使在这个简单的示例中它产生了正确的结果。但是，一旦你JOIN更多的表引用，，你将很难从你的结果中正确删除重复项。</p>
<p>更多的关于DISTINCT滥用的问题，可以访问这里的<a href="http://blog.jooq.org/2013/07/30/10-common-mistakes-java-developers-make-when-writing-sql/" target="_blank" rel="external">博客</a>。</p>
</li>
</ul>
<h3 id="ANTI-JOIN（反连接）"><a href="#ANTI-JOIN（反连接）" class="headerlink" title="ANTI JOIN（反连接）"></a><strong>ANTI JOIN（反连接）</strong></h3><p> 这个关系的概念跟半连接刚好相反。您可以简单地通过将 NOT 关键字添加到IN 或 EXISTS中生成它。在下例中，我们选择那些没有任何书籍的作者：</p>
<pre><code>-- Using IN

FROM author WHERE author.id NOT IN (SELECT book.author_id FROM book) -- Using EXISTS

FROM author WHERE NOT EXISTS (SELECT 1 FROM book WHERE book.author_id = author.id)
</code></pre><p> 同样的规则对性能、可读性、表现力都适用。然而，当使用NOT IN时对NULLs会有一个小警告，这个问题有点超出本教程范围。</p>
<h3 id="CROSS-JOIN（交叉连接）"><a href="#CROSS-JOIN（交叉连接）" class="headerlink" title="CROSS JOIN（交叉连接）"></a><strong>CROSS JOIN（交叉连接）</strong></h3><p> 结合第一个表中的内容和第二个表中的内容，引用两个join表交叉生成一个新的东西。我们之前已经看到，这可以在FROM语句中通过逗号分隔表引用来实现。在你确实需要的情况下，可以在SQL语句中明确地写一个CROSS JOIN。</p>
<pre><code>-- Combine every author with every book
 author CROSS JOIN book
</code></pre><h3 id="DIVISION（除法）"><a href="#DIVISION（除法）" class="headerlink" title="DIVISION（除法）"></a><strong>DIVISION（除法）</strong></h3><p> 关系分割就是一只真正的由自己亲自喂养的野兽。简而言之，如果JOIN是乘法，那么除法就是JOIN的反义词。在SQL中，除法关系难以表达清楚。由于这是一个初学者的教程，解释这个问题超出了我们的教程范围。当然如果你求知欲爆棚，那么就看<a href="http://blog.jooq.org/2012/03/30/advanced-sql-relational-division-in-jooq/" target="_blank" rel="external">这里</a>，<a href="http://en.wikipedia.org/wiki/Relational_algebra#Division" target="_blank" rel="external">这里</a>还有<a href="https://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/" target="_blank" rel="external">这里</a>。</p>
<p> <strong>从中我们学到了什么呢？</strong></p>
<p> 让我们把前面讲到的内容再次牢记于心。SQL是表引用。连接表是相当复杂的表引用。但关系表述和SQL表述还是有点区别的，并不是所有的关系连接操作都是正规的SQL连接操作。对关系理论有一点实践与认识，你就可以选择JOIN正确的关系类型并能将其转化为正确的SQL。</p>
<h2 id="7、SQL的派生表就像表的变量"><a href="#7、SQL的派生表就像表的变量" class="headerlink" title="7、SQL的派生表就像表的变量"></a><strong>7、SQL的派生表就像表的变量</strong></h2><p> 前文，我们已经了解到SQL是一种声明性语言，因此不会有变量。（虽然在一些SQL语句中可能会存在）但你可以写这样的变量。那些野兽一般的表被称为派生表。</p>
<p> 派生表只不过是包含在括号里的子查询。</p>
<pre><code>-- A derived table

FROM (SELECT * FROM author)
</code></pre><p> 需要注意的是，一些SQL方言要求派生表有一个关联的名字（也被称为别名）。</p>
<pre><code>-- A derived table with an alias

FROM (SELECT * FROM author) a
</code></pre><p>当你想规避由SQL子句逻辑排序造成的问题时，你会发现派生表可以用帅呆了来形容。例如，如果你想在SELECT和WHERE子句中重用一个列表达式，只写（Oracle方言）：</p>
<pre><code>-- Get authors&#39; first and last names, and their age in days

SELECT first_name, last_name, age FROM ( SELECT first_name, last_name, current_date - date_of_birth age FROM author ) -- If the age is greater than 10000 days

WHERE age &gt; 10000
</code></pre><p> 注意，一些数据库和SQL:1999标准里已将派生表带到下一级别，,引入公共表表达式。这将允许你在单一的SQL SELECT中重复使用相同的派生表。上面的查询将转化为类似这样的：</p>
<pre><code>WITH a AS ( SELECT first_name, last_name, current_date - date_of_birth age FROM author ) SELECT *

FROM a WHERE age &gt; 10000
</code></pre><p> 很明显，对广泛重用的常见SQL子查询，你也可以灌输具体”a”到一个独立视图中。想要了解更多就看<a href="http://en.wikipedia.org/wiki/View_(SQL" target="_blank" rel="external">这里</a>)。</p>
<p> <strong>从中我们学到了什么呢？</strong></p>
<p> 再温习一遍，SQL主要是关于表引用，而不是列。好好利用这些表引用。不要害怕写派生表或其他复杂的表引用。</p>
<h2 id="8、SQL-GROUP-BY转换之前的表引用"><a href="#8、SQL-GROUP-BY转换之前的表引用" class="headerlink" title="8、SQL GROUP BY转换之前的表引用"></a><strong>8、SQL GROUP BY转换之前的表引用</strong></h2><p> 让我们重新考虑我们之前的FROM语句：</p>
<pre><code>FROM a, b
</code></pre><p> 现在,让我们来应用一个GROUP BY语句到上述组合表引用</p>
<pre><code>GROUP BY A.x, A.y, B.z
</code></pre><p> 这会产生一个只有其余三个列(!)的新的表引用。让我们再消化一遍。如果你用了GROUP BY，那么你在所有后续逻辑条款-包括选择中减少可用列的数量。这就是为什么你只可以从SELECT语句中的GROUP BY语句引用列语法的原因。</p>
<ul>
<li><p>请注意，其他列仍然可能可作为聚合函数的参数：</p>
<p>SELECT A.x, A.y, SUM(A.z) FROM A GROUP BY A.x, A.y</p>
</li>
<li><p>值得注意并很不幸的是，MySQL不遵守这一标准，只会造成混乱。不要陷入MySQL的把戏。GROUP BY转换表引用，因此你可以只引用列也引用GROUPBY语句。</p>
</li>
</ul>
<p>从中我们学到了什么呢？</p>
<p>GROUP BY，在表引用上操作，将它们转换成一个新表。</p>
<h2 id="9、SQL-SELECT在关系代数中被称为投影"><a href="#9、SQL-SELECT在关系代数中被称为投影" class="headerlink" title="9、SQL SELECT在关系代数中被称为投影"></a><strong>9、SQL SELECT在关系代数中被称为投影</strong></h2><p> 当它在关系代数中使用时，我个人比较喜欢用”投影”一词中。一旦你生成你的表引用，过滤，转换它，你可以一步将它投影到另一个表中。SELECT语句就像一个投影机。表函数利用行值表达式将之前构造的表引用的每个记录转化为最终结果。</p>
<p> 在SELECT语句中，你终于可以在列上操作，创建复杂的列表达式作为记录/行的一部分。</p>
<p> 有很多关于可用的表达式，函数性质等的特殊规则。最重要的是，你应该记住这些：</p>
<p> 1、你只能使用从“output”表引用产生的列引用</p>
<p> 2、如果你有GROUP BY语句，你只可能从该语句或聚合函数引用列</p>
<p> 3、当你没有GROUP BY语句时，你可以用窗口函数替代聚合函数</p>
<p> 4、如果你没有GROUP BY语句，你就不能将聚合函数与非聚合函数结合起来</p>
<p> 5、这有一些关于在聚合函数包装常规函数的规则，反之亦然</p>
<p> 6、还有…</p>
<p> 嗯，这有很多复杂的规则。他们可以填补另一个教程。例如，之所以你不能将聚合函数与非聚合函数结合起来投影到没有GROUP BY的SELECT语句中是因为：</p>
<p> 1、凭直觉，没有任何意义。</p>
<p> 2、对一个SQL初学者来说，直觉还是毫无帮助的，语法规则则可以。SQL:1999年引入了分组集，SQL：2003引入了空分组集GROUP BY()。每当存在没有显式GROUP BY语句的聚合函数时就会应用隐式的空分组集（规则2）。因此，最初关于逻辑顺序的那个规则就不完全正确了，SELECT的投影也会影响前面的逻辑结果，但语法语句GROUP BY却不受影响。</p>
<p>是不是有点迷糊？其实我也是，让我们看一些简单的吧。</p>
<p> <strong>从中我们学到了什么呢？</strong></p>
<p> 在SQL语句中，SELECT语句可能是最复杂的语句之一，即使它看起来是那么的简单。所有其他语句只不过是从这个到另一个表引用的的输送管道。通过将它们完全转化，后期地对它们应用一些规则，SELECT语句完完全全地搅乱了这些表引用的美。</p>
<p> 为了了解SQL，重要的是要理解其他的一切，都要尝试在SELECT之前解决。即便SELECT在语法顺序中排第一的语句，也应该将它放到最后。</p>
<h2 id="10-相对简单一点的SQL-DISTINCT-UNION-ORDER-BY-和OFFSET"><a href="#10-相对简单一点的SQL-DISTINCT-UNION-ORDER-BY-和OFFSET" class="headerlink" title="10.相对简单一点的SQL DISTINCT,UNION,ORDER BY,和OFFSET"></a><strong>10.相对简单一点的SQL DISTINCT,UNION,ORDER BY,和OFFSET</strong></h2><p> 看完复杂的SELECT之后，我们看回一些简单的东西。</p>
<ul>
<li>集合运算（DISTINCT和UNION）</li>
<li><p>排序操作（ORDER BY,OFFSET..FETCH）</p>
<p><strong>集合运算</strong></p>
<p>集合运算在除了表其实没有其他东西的“集”上操作。嗯，差不多是这样，从概念上讲，它们还是很容易理解的</p>
</li>
<li><p>DISTINCT投影后删除重复项。</p>
</li>
<li>UNION求并集，删除重复项。</li>
<li>UNION ALL求并集，保留重复项。</li>
<li>EXCEPT求差集（在第一个子查询结果中删除第二个子查询中也含有的记录删除），删除重复项。</li>
<li><p>INTERSECT求交集（保留所有子查询都含有的记录），删除重复项。</p>
<p>所有这些删除重复项通常是没有意义的，很多时候，当你想要连接子查询时，你应该使用UNION ALL。</p>
<p><strong>排序操作</strong></p>
<p>排序不是一个关系特征，它是SQL仅有的特征。在你的SQL语句中，它被应用在语法排序和逻辑排序之后。保证可以通过索引访问记录的唯一可靠方法是使用ORDER BY a和OFFSET..FETCH。所有其他的排序总是任意的或随机的，即使它看起来像是可再现的。</p>
<p>OFFSET..FETCH是唯一的语法变体。其他变体包括MySQL’和PostgreSQL的LIMIT..OFFSET，或者SQL Server和Sybase的TOP..START AT（<a href="http://www.jooq.org/doc/3.1/manual/sql-building/sql-statements/select-statement/limit-clause/" target="_blank" rel="external">这里</a>）。</p>
<p><strong>让我们开始应用吧</strong></p>
<p>跟其他每个语言一样，要掌握SQL语言需要大量的实践。上述10个简单的步骤将让你每天编写SQL时更有意义。另一方面，你也可以从常见的错误中学习到更多。下面的两篇文章列出许多Java（和其他）开发者写SQL时常见的错误：</p>
<p>· <a href="http://blog.jooq.org/2013/07/30/10-common-mistakes-java-developers-make-when-writing-sql/" target="_blank" rel="external">10 Common Mistakes Java Developers Make when Writing SQL</a></p>
<p>· <a href="http://blog.jooq.org/2013/08/12/10-more-common-mistakes-java-developers-make-when-writing-sql/" target="_blank" rel="external">10 More Common Mistakes Java Developers Make when Writing SQL</a></p>
<p>英文来源：<a href="http://tech.pro/tutorial/1555/10-easy-steps-to-a-complete-understanding-of-sql" target="_blank" rel="external">10 Easy Steps to a Complete Understanding of SQL</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;声明，本篇转载自 &lt;a href=&quot;http://www.cnblogs.com/shockerli/p/10-easy-steps-to-a-complete-understanding-of-sql.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;简单十步让你全面理解SQL&lt;/a&gt;。第一次看感觉好深，所以转载来慢慢消化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很多程序员认为SQL是一头难以驯服的野兽。它是为数不多的声明性语言之一，也因为这样，其展示了完全不同于其他的表现形式、命令式语言、 面向对象语言甚至函数式编程语言（虽然有些人觉得SQL 还是有些类似功能）。&lt;/p&gt;
&lt;p&gt;为了向你呈现SQL的优美！下面的教程面向于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已经使用过但没有完全理解SQL的读者&lt;/li&gt;
&lt;li&gt;已经差不多了解SQL但从未真正考虑过它的语法的读者&lt;/li&gt;
&lt;li&gt;想要指导他人学习SQL的读者&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://nijun.me/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据类型</title>
    <link href="http://nijun.me/2017/07/13/00001-Database-2017-07-13-Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://nijun.me/2017/07/13/00001-Database-2017-07-13-Mysql数据类型/</id>
    <published>2017-07-13T08:12:01.000Z</published>
    <updated>2017-07-13T15:07:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要整理了 Mysql中 的数据类型。</p>
<a id="more"></a>
<p><strong>1、整型</strong></p>
<table>
<thead>
<tr>
<th><strong>MySQL数据类型</strong></th>
<th><strong>含义（有符号）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>tinyint(m)</td>
<td>1个字节  范围(-128~127)</td>
</tr>
<tr>
<td>smallint(m)</td>
<td>2个字节  范围(-32768~32767)</td>
</tr>
<tr>
<td>mediumint(m)</td>
<td>3个字节  范围(-8388608~8388607)</td>
</tr>
<tr>
<td>int(m)</td>
<td>4个字节  范围(-2147483648~2147483647)</td>
</tr>
<tr>
<td>bigint(m)</td>
<td>8个字节  范围(+-9.22*10的18次方)</td>
</tr>
</tbody>
</table>
<p>取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。<br>int(m)里的m是表示SELECT查询结果集中的显示宽度，并不影响实际的取值范围，没有影响到显示的宽度，不知道这个m有什么用。</p>
<p><strong>2、浮点型(float和double)</strong></p>
<table>
<thead>
<tr>
<th><strong>MySQL数据类型</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>float(m,d)</td>
<td>单精度浮点型    8位精度(4字节)     m总个数，d小数位</td>
</tr>
<tr>
<td>double(m,d)</td>
<td>双精度浮点型    16位精度(8字节)    m总个数，d小数位</td>
</tr>
</tbody>
</table>
<p>设一个字段定义为float(5,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。</p>
<p><strong>3、定点数</strong></p>
<p>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。<br>decimal(m,d) 参数m&lt;65 是总个数，d&lt;30 且 d&lt;m 是小数位。</p>
<p><strong>4、字符串(char,varchar,_text)</strong></p>
<table>
<thead>
<tr>
<th><strong>MySQL数据类型</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>char(n)</td>
<td>固定长度，最多255个字符</td>
</tr>
<tr>
<td>varchar(n)</td>
<td>固定长度，最多65535个字符</td>
</tr>
<tr>
<td>tinytext</td>
<td>可变长度，最多255个字符</td>
</tr>
<tr>
<td>text</td>
<td>可变长度，最多65535个字符</td>
</tr>
<tr>
<td>mediumtext</td>
<td>可变长度，最多2的24次方-1个字符</td>
</tr>
<tr>
<td>longtext</td>
<td>可变长度，最多2的32次方-1个字符</td>
</tr>
</tbody>
</table>
<p>char和varchar：</p>
<ol>
<li>char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。 </li>
<li>char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，所以varchar(4),存入3个字符将占用4个字节。 </li>
<li>char类型的字符串检索速度要比varchar类型的快。<br>varchar和text： </li>
<li>varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，text是实际字符数+2个字节。 </li>
<li>text类型不能有默认值。 </li>
<li>varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。</li>
</ol>
<p><strong>5.二进制数据(Blob)</strong></p>
<ol>
<li>BLOB和text存储方式不同，TEXT以文本方式存储，英文存储区分大小写，而Blob是以二进制方式存储，不分大小写。 </li>
<li>BLOB存储的数据只能整体读出。 </li>
<li>TEXT可以指定字符集，BLO不用指定字符集。</li>
</ol>
<p><strong>6.日期时间类型</strong></p>
<table>
<thead>
<tr>
<th><strong>MySQL数据类型</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>date</td>
<td>日期 ‘2008-12-2’</td>
</tr>
<tr>
<td>time</td>
<td>时间 ‘12:25:36’</td>
</tr>
<tr>
<td>datetime</td>
<td>日期时间 ‘2008-12-2 22:06:44’</td>
</tr>
<tr>
<td>timestamp</td>
<td>自动存储记录修改时间</td>
</tr>
</tbody>
</table>
<p>若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。</p>
<p><strong>数据类型的属性</strong></p>
<table>
<thead>
<tr>
<th><strong>MySQL关键字</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>NULL</td>
<td>数据列可包含NULL值</td>
</tr>
<tr>
<td>NOT NULL</td>
<td>数据列不允许包含NULL值</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>默认值</td>
</tr>
<tr>
<td>PRIMARY KEY</td>
<td>主键</td>
</tr>
<tr>
<td>AUTO_INCREMENT</td>
<td>自动递增，适用于整数类型</td>
</tr>
<tr>
<td>UNSIGNED</td>
<td>无符号</td>
</tr>
<tr>
<td>CHARACTER SET name</td>
<td>指定一个字符集</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要整理了 Mysql中 的数据类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://nijun.me/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>各大数据库对应的jar、驱动类名和URL格式</title>
    <link href="http://nijun.me/2017/07/13/00001-Database-2017-07-13-%E5%90%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E5%BA%94%E7%9A%84jar%E3%80%81%E9%A9%B1%E5%8A%A8%E7%B1%BB%E5%90%8D%E5%92%8CURL%E6%A0%BC%E5%BC%8F/"/>
    <id>http://nijun.me/2017/07/13/00001-Database-2017-07-13-各大数据库对应的jar、驱动类名和URL格式/</id>
    <published>2017-07-13T06:47:29.000Z</published>
    <updated>2017-07-13T06:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="各种数据库对应的jar包"><a href="#各种数据库对应的jar包" class="headerlink" title="各种数据库对应的jar包"></a><strong>各种数据库对应的jar包</strong></h2><table>
<thead>
<tr>
<th><strong>数据库类型<em>**</em></strong></th>
<th><strong>对应的**</strong>Jar<strong><strong>文件**</strong></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Oracle 8i</td>
<td>classes12.zip 或 ojdbc14.jar</td>
</tr>
<tr>
<td>Sybase</td>
<td>jconn2.jar 或 jconn3.jar</td>
</tr>
<tr>
<td>Mysql</td>
<td>mysql-connector-java-3.1.1-alpha-bin.jar 或mysql-connector-java-5.0.2-beta-bin.jar</td>
</tr>
<tr>
<td>SQLServer 2000</td>
<td>msbase.jar、msutil.jar、mssqlserver.jar</td>
</tr>
<tr>
<td>SQLServer 2005</td>
<td>sqljdbc.jar</td>
</tr>
<tr>
<td>SQLServer 7.0</td>
<td>jtds-1.2.2.jar</td>
</tr>
<tr>
<td>Informix</td>
<td>ifxjdbc.jar</td>
</tr>
<tr>
<td>DB2</td>
<td>db2jcc.jar、db2jcc_license_cu.jar</td>
</tr>
</tbody>
</table>
<h2 id="各种数据库对应的驱动类名和URL格式"><a href="#各种数据库对应的驱动类名和URL格式" class="headerlink" title="各种数据库对应的驱动类名和URL格式"></a><strong>各种数据库对应的驱动类名和URL格式</strong></h2><p>下面是对各种数据库的驱动类名和URL格式的汇总。如表3所示。其中hostip代表ip地址，dbname代表数据库名。</p>
<table>
<thead>
<tr>
<th><strong>数据库<em>**</em></strong></th>
<th><strong>驱动类名<em>**</em></strong></th>
<th><strong>URL**</strong>格式<strong>**</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Oracle</td>
<td>oracle.jdbc.driver.OracleDriver</td>
<td>jdbc:oracle:thin:@hostip:1521:dbname</td>
</tr>
<tr>
<td>Sybase</td>
<td>com.sybase.jdbc2.jdbc.SybDriver</td>
<td>jdbc:sybase:Tds:hostip:4100/dbname</td>
</tr>
<tr>
<td>Mysql</td>
<td>com.mysql.jdbc.Driver</td>
<td>jdbc:mysql://hostip:3306/dbname?useUnicode=true&amp;characterEncoding=GBK</td>
</tr>
<tr>
<td>SQLServer 2000</td>
<td>com.microsoft.jdbc.sqlserver.SQLServerDriver</td>
<td>jdbc:microsoft:sqlserver://hostip:1433;DatabaseName=dbname</td>
</tr>
<tr>
<td>SQLServer 2005</td>
<td>com.microsoft.sqlserver.jdbc.SQLServerDriver</td>
<td>jdbc:sqlserver://hostip:1433;DatabaseName=dbname</td>
</tr>
<tr>
<td>SQLServer 7.0</td>
<td>net.sourceforge.jtds.jdbc.Driver</td>
<td>jdbc:jtds:sqlserver://hostip:1433/dbname</td>
</tr>
<tr>
<td>DB2</td>
<td>com.ibm.db2.jcc.DB2Driver</td>
<td>jdbc:db2://hostip:50000/dbname</td>
</tr>
<tr>
<td>Informix</td>
<td>com.informix.jdbc.IfxDriver</td>
<td>jdbc:informix-sqli://hostip:port/dbname:informixserver=<dbservername></dbservername></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;各种数据库对应的jar包&quot;&gt;&lt;a href=&quot;#各种数据库对应的jar包&quot; class=&quot;headerlink&quot; title=&quot;各种数据库对应的jar包&quot;&gt;&lt;/a&gt;&lt;strong&gt;各种数据库对应的jar包&lt;/strong&gt;&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;

    
    </summary>
    
    
      <category term="Database" scheme="http://nijun.me/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>JSP学习笔记（1）-JSP简介</title>
    <link href="http://nijun.me/2017/07/12/JSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89-JSP%E7%AE%80%E4%BB%8B/"/>
    <id>http://nijun.me/2017/07/12/JSP学习笔记（1）-JSP简介/</id>
    <published>2017-07-12T10:55:24.000Z</published>
    <updated>2017-07-12T10:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是JSP？"><a href="#1-什么是JSP？" class="headerlink" title="1.什么是JSP？"></a>1.什么是JSP？</h2><p>JSP是Java server page的缩写，有sun公司倡导，许多公司参与，于1999年推出的一种web服务设计标准。<br>JSP基于Java Servlet以及整个java体系的Web开发技术。<br>Java servlet 就是编写在服务器端创建对象的java类，习惯上称为servlet类，servlet类的对象习惯上称为一个servlet。<br>那么二者的关系是什么呢？<br>Java Servlet是java语言的一部分，而jsp是基于java servlet的，jsp具备了几乎所有java servlet的好处，当客户请求一个jsp页面时，tomcat服务器自动生成java文件、编译java文件，并用编译得到的字节码文件在服务器端创建一个servlet。<br>Java servlet是java的一部分，jsp是java servlet一个成功的应用，但是jsp并不是java servlet的一个子集，jsp可以配合javabean有效分离页面视图和数据存储，也可以是jsp+javabean+servlet创建web应用。</p>
<h2 id="2-JSP的运行原理？"><a href="#2-JSP的运行原理？" class="headerlink" title="2.JSP的运行原理？"></a>2.JSP的运行原理？</h2><p>当服务器上的一个JSP页面第一次被请求执行时，服务器上的JSP引擎首先将JSP页面文件转换成一个java文件，并编译这个Java文件生成字节码文件，然后执行字节码文件响应客户的请求。当这个页面再次被请求执行时，JSP引擎将直接执行字节码文件来响应客户。<br>字节码文件的主要工作：<br>（1）处理JSP标记，并将有关的处理结果发送到客户的浏览器<br>（2）把JSP页面中的HTML标记符号交给客户浏览器<br>（3）执行&lt;%%&gt;之间的java代码，并返回结果给客户浏览器<br>（4）多用户访问的时候，Tomcat给每个客户一个线程，通过执行常驻内存的字节码文件响应客户的请求</p>
<h2 id="3-JSP运行环境"><a href="#3-JSP运行环境" class="headerlink" title="3.JSP运行环境"></a>3.JSP运行环境</h2><p>Tomcat环境配置</p>
<p>JDK必备，注意设置Java环境变量<br>Tomcat 安装完成浏览器输入：localhost:8080或者127.0.0.1:8080测试是否安装成功<br>Tomact 配置文件 ../conf/server.xml<br>端口配置：</p>
<p><connector port="8080" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443"></connector></p>
<h2 id="4-Tomcat的Web服务目录"><a href="#4-Tomcat的Web服务目录" class="headerlink" title="4.Tomcat的Web服务目录"></a>4.Tomcat的Web服务目录</h2><p>目录：../webapps/  Root目录为根目录，localhost:8080默认访问root目录下的index.jsp页面<br>新建Web服务目录</p>
<p>…</p>
<p><context path="pinnsvin" docbase="D:\workplace\Tomcat" debug="0" reloadable="true"><br><br>localhost:8080/pinnsvin 就可以访问到”D:\workplace\Tomcat”目录了</context></p>
<p>项目目录：默认在tomcat目录下webapps目录下，可以在此目录下建立项目目录，访问：“localhost:8080/项目目录/文件.jsp”。如果，项目下存在index.jsp可以使用”localhost:8080/项目目录“访问。</p>
<h2 id="5-设置Tomcat虚拟目录"><a href="#5-设置Tomcat虚拟目录" class="headerlink" title="5.设置Tomcat虚拟目录"></a>5.设置Tomcat虚拟目录</h2><p>就是这种效果</p>
<p> 要如何实现呢？</p>
<p>在tomcat目录下conf/server.xml中配置</p>
<pre><code>  &lt;Context path=&quot;cm&quot; docBase=&quot;E:\CM&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt;
</code></pre><p>修改conf/web.xml</p>
<pre><code>    &lt;param-value&gt;false&lt;/param-value&gt;中false改为true
    &lt;servlet&gt;
        &lt;servlet-name&gt;default&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;debug&lt;/param-name&gt;
            &lt;param-value&gt;0&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;listings&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是JSP？&quot;&gt;&lt;a href=&quot;#1-什么是JSP？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是JSP？&quot;&gt;&lt;/a&gt;1.什么是JSP？&lt;/h2&gt;&lt;p&gt;JSP是Java server page的缩写，有sun公司倡导，许多公司参与，于1
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码块测试</title>
    <link href="http://nijun.me/2017/07/04/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%B5%8B%E8%AF%95/"/>
    <id>http://nijun.me/2017/07/04/代码块测试/</id>
    <published>2017-07-04T06:12:44.000Z</published>
    <updated>2017-07-15T06:59:35.000Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="">『前往』</a><a href="">「前往」</a></p>
<pre><code class="java">public void postRunningActDate(String tag, int projectId, int studentId, int distance, long costTime, long targetTime,long startTime, int stepCount, ResponseCallback callback) {
        String url = API_SCHEME + INIT_PUSH;
        HashMap params = new HashMap();
        params.put(&quot;projectId&quot;, projectId);
        params.put(&quot;studentId&quot;, studentId);
        params.put(&quot;distance&quot;, distance);
        params.put(&quot;costTime&quot;, costTime);
        params.put(&quot;targetTime&quot;, targetTime);
        params.put(&quot;startTime&quot;, startTime);
        params.put(&quot;stepCount&quot;, stepCount);
        Log.d(TAG, &quot;params: &quot; + params);
        NetworkInterface.instance().connected(HttpMethod.POST, url, tag, params, CacheMode.DEFAULT, false, callback);
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;a href=&quot;&quot;&gt;『前往』&lt;/a&gt;&lt;a href=&quot;&quot;&gt;「前往」&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public void postRunningActDate(String tag, int projectId, int student
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android异步消息处理机制（一）</title>
    <link href="http://nijun.me/2017/06/14/00001-Android-2017-06-14-Android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://nijun.me/2017/06/14/00001-Android-2017-06-14-Android异步消息处理机制（一）/</id>
    <published>2017-06-14T02:37:55.000Z</published>
    <updated>2017-07-13T15:24:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>两个问题：</p>
<p>​    1、在子线程中如何创建的Handler？需要先做什么？如何发送消息？</p>
<p>​    2、Handler中发送的消息去哪啦？为什么handleMessage中又能得到这个Message？</p>
<a id="more"></a>
<p><strong>首先明确</strong>：网络请求必须在子线程中执行，不然会出 <code>NetworkOnMainThreadException</code> 异常。</p>
<p>参考自<a href="http://blog.csdn.net/guolin_blog" target="_blank" rel="external">郭霖</a>的 <a href="http://blog.csdn.net/guolin_blog/article/details/9991569" target="_blank" rel="external">android 异步消息处理机制</a></p>
<h1 id="一、如何在子线程创建Headler"><a href="#一、如何在子线程创建Headler" class="headerlink" title="一、如何在子线程创建Headler"></a>一、如何在子线程创建Headler</h1><p>首先我们想在子线程中创建一个Handler。（注意是在子线程中）</p>
<p>在Handler的构造函数中会调用Looper.myLooper() 得到当前的线程的Looper对象，如果没有的话就会报 ” Can’t create handler inside thread that has not called Looper.prepare().“ 这个错误。</p>
<p>prepare() 会先判断sThreadLocal.get() 这个方法从当前线程得到Looper的对象是否为空，如果为空就创建一个，不为空会报“Only one Looper may be created per thread”错误。</p>
<p>ActivityThread的main()方法中，会调用 Looper.prapareMainLooper方法，这其中又会调用  Looper.prepare() 方法，因此主线程中始终有一个Looper对象。</p>
<p>总结一下，普通线程必须先调用Looper.prepare()，然后才能创建Handler对象，</p>
<h1 id="二、Headler发送消息源码解析"><a href="#二、Headler发送消息源码解析" class="headerlink" title="二、Headler发送消息源码解析"></a>二、Headler发送消息源码解析</h1><p>创建完Handler之后，只要用把 bundle 放到 Message 中，并且再把 message放到 handler 发送即可。但是这里 Handler 把消息发送到哪里，为什么在 handleMessage 又能得到这个 Message 呢。</p>
<p>除了sendMessageAtFrontOfQueue之外，其他发送消息的方法都会辗转到sendMessageAtTime()中。而入队操作就是在这个sendMessageAtTime() 方法中。</p>
<p>Looper.loop()中包含出队操作，这个方法会一直等待新的消息入队，不然就会进入阻塞状态。每当又一个消息出队 queue.next() ，那就会调用当前handler的dispatchMessage()方法。在dispatchMessage() 方法里就会调用 handleMessage(msg)，这样我们在handleMessage就可以得到这个Message了。</p>
<p>MessageQueue 在 Looper 的构造函数中创建，那么一个 Looper 对应了一个 MessageQueue。</p>
<p>一个最标准的异步消息处理线程的写法应该是这样：</p>
<pre><code class="java">class LooperThread extends Thread {  
      public Handler mHandler;  

      public void run() {  
          //先调用Looper.prepare()方法，也就是说必须要有一个 looper 对象。
          Looper.prepare();  

          mHandler = new Handler() {  
              public void handleMessage(Message msg) {  
                  // process incoming messages here  
              }  
          };  
            //调用之后就会一直在MessageQueue中循环遍历Message，如果没有新的消息，就会挂起。
          Looper.loop();  
      }  
  }
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个问题：&lt;/p&gt;
&lt;p&gt;​    1、在子线程中如何创建的Handler？需要先做什么？如何发送消息？&lt;/p&gt;
&lt;p&gt;​    2、Handler中发送的消息去哪啦？为什么handleMessage中又能得到这个Message？&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://nijun.me/categories/Android/"/>
    
    
      <category term="Android" scheme="http://nijun.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android消息处理机制之二：消息中obtain源代码剖析</title>
    <link href="http://nijun.me/2017/06/14/00001-Android-2017-06-14-Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%B6%88%E6%81%AF%E4%B8%ADobtain%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://nijun.me/2017/06/14/00001-Android-2017-06-14-Android消息处理机制之二：消息中obtain源代码剖析/</id>
    <published>2017-06-14T02:36:40.000Z</published>
    <updated>2017-07-13T15:24:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Message中obtain()源码分析</p>
<a id="more"></a>
<p>参考自 AHuier的<a href="http://blog.csdn.net/xukunhui2/article/details/17012923" target="_blank" rel="external">Android消息处理机制之二：消息中obtain()源代码剖析</a> </p>
<p>obtain的源码，可见是从消息池中取出对象。这里为了防止多个任务访问消息池获取对象，使用 synchronized(sPoolSync) 将 obtain() 方法上锁了。</p>
<pre><code class="java">private static final Object sPoolSync = new Object();  
private static Message sPool;  
private static int sPoolSize = 0;  

private static final int MAX_POOL_SIZE = 10;  

/** 
 * Return a new Message instance from the global pool. Allows us to 
 * avoid allocating new objects in many cases. 
 */  
public static Message obtain() {  
    synchronized (sPoolSync) {  
        if (sPool != null) {  
            Message m = sPool;  
            sPool = m.next;  
            m.next = null;  
            sPoolSize--;  
            return m;  
        }  
    }  
    return new Message();  
}
</code></pre>
<p>1) 通过 Message.obtain()方式获取Message对象</p>
<pre><code class="java">public class MyThread implements Runnable{  

    @Override  
    public void run() {  
        // 使用第一种构造方法  
        Message message = Message.obtain();  
        message.what = 1;  
        message.arg1 = 1;  
        message.arg2 = 3;  
        message.obj = &quot;SmartNi&quot;;  
        handler.sendMessage(message);  
    }          
}
</code></pre>
<p>2) 通过 Message.obtain(Handler h)的方式获取Message对象</p>
<p>首先查看一下obtain(Handler h)的源码，可见 message 的目标对象已经指向了 Handler ，那么在发送消息的时候就直接调用 sendToTarget() 方法即可。</p>
<pre><code class="java">     /**
     * Same as {@link #obtain()}, but sets the value for the &lt;em&gt;target&lt;/em&gt; member on the Message returned.
     * @param h  Handler to assign to the returned Message object&#39;s &lt;em&gt;target&lt;/em&gt; member.
     * @return A Message object from the global pool.
     */
    public static Message obtain(Handler h) {
        Message m = obtain();
        m.target = h;
        return m;
    }
</code></pre>
<pre><code class="java">/* 
 *  第二种获取Message对象的方法 
 *  public static Message obtain (Handler h) 
 *  传递一个关联到消息Handler. 
 */  
Message message = Message.obtain(handler);  
message.what = 1;  
message.arg1 = 1;  
message.arg2 = 3;  
message.obj = &quot;SmartNi&quot;;  
message.sendToTarget(); // 完成发送消息的动作
</code></pre>
<p>因为</p>
<pre><code class="java">...  
/*package*/ Handler target;    
...   
/** 
 * Sends this Message to the Handler specified by {@link #getTarget}. 
 * Throws a null pointer exception if this field has not been set. 
 */  
public void sendToTarget() {  
    target.sendMessage(this);  //这里
}
</code></pre>
<p>3) 通过 Message.obtain(Handler h,int what)的方式获取Message对象</p>
<pre><code class="java">/** 
 * Same as {@link #obtain()}, but sets the values for both &lt;em&gt;target&lt;/em&gt; and 
 * &lt;em&gt;what&lt;/em&gt; members on the Message. 
 * @param h  Value to assign to the &lt;em&gt;target&lt;/em&gt; member. 
 * @param what  Value to assign to the &lt;em&gt;what&lt;/em&gt; member. 
 * @return A Message object from the global pool. 
 */  
public static Message obtain(Handler h, int what) {  
    Message m = obtain();  
    m.target = h;  
    m.what = what;  

    return m;  
}
</code></pre>
<p>4) 通过 Message.obtain(Handler h, int what, int arg1, int arg2, Object obj)的方式获取Message对象</p>
<pre><code class="java">/* 
 * public static Message obtain (Handler h, int what, int arg1, int arg2, Object obj) 
 * 关联Handler和传递Message的几种常用属性值 
 */  
Message message = Message.obtain(handler, 1, 1, 3, &quot;SmartNi&quot;);  
message.sendToTarget();
</code></pre>
<pre><code class="java">/** 
 * Same as {@link #obtain()}, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;,  
 * &lt;em&gt;arg1&lt;/em&gt;, &lt;em&gt;arg2&lt;/em&gt;, and &lt;em&gt;obj&lt;/em&gt; members. 
 *  
 * @param h  The &lt;em&gt;target&lt;/em&gt; value to set. 
 * @param what  The &lt;em&gt;what&lt;/em&gt; value to set. 
 * @param arg1  The &lt;em&gt;arg1&lt;/em&gt; value to set. 
 * @param arg2  The &lt;em&gt;arg2&lt;/em&gt; value to set. 
 * @param obj  The &lt;em&gt;obj&lt;/em&gt; value to set. 
 * @return  A Message object from the global pool. 
 */  
public static Message obtain(Handler h, int what,   
        int arg1, int arg2, Object obj) {  
    Message m = obtain();  
    m.target = h;  
    m.what = what;  
    m.arg1 = arg1;  
    m.arg2 = arg2;  
    m.obj = obj;  

    return m;  
}
</code></pre>
<p>5) 通过上述几个例子我们可以知道Message中的obtain()的几种重载方法在底层的实现都是大同小异的,他们都是底层都是首先调用obtain()方法来从消息池中获得一个消息的对象的。然后在通过参数传递来封装指定的Handler和需要携带的数据。如果使用这些重载的方法建议完成数据封装之后调用sendToTarget()方法。这就是几种obtain()重载方法的不同。</p>
<p>6) 这里我们需要特别注意Message中的这个重载方法:<strong>Message obtain (Message orig)</strong> 它是将原有的消息体作为一个新的消息参数来发送的,我们看一下它的源代码。</p>
<pre><code class="java">/** 
 * Same as {@link #obtain()}, but copies the values of an existing 
 * message (including its target) into the new one. 
 * @param orig Original message to copy. 
 * @return A Message object from the global pool. 
 */  
public static Message obtain(Message orig) {  
    Message m = obtain();  
    m.what = orig.what;  
    m.arg1 = orig.arg1;  
    m.arg2 = orig.arg2;  
    m.obj = orig.obj;  
    m.replyTo = orig.replyTo;  
    if (orig.data != null) {  
        m.data = new Bundle(orig.data);  
    }  
    m.target = orig.target;  
    m.callback = orig.callback;  

    return m;  
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Message中obtain()源码分析&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://nijun.me/categories/Android/"/>
    
    
      <category term="Android" scheme="http://nijun.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android消息处理机制之三：Handler中sendMessage源代码剖析</title>
    <link href="http://nijun.me/2017/06/14/00001-Android-2017-06-14-Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B9%8B%E4%B8%89%EF%BC%9AHandler%E4%B8%ADsendMessage%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://nijun.me/2017/06/14/00001-Android-2017-06-14-Android消息处理机制之三：Handler中sendMessage源代码剖析/</id>
    <published>2017-06-14T02:35:30.000Z</published>
    <updated>2017-07-13T15:24:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Handler中sendMessage源代码剖析。</p>
<a id="more"></a>
<p>参考自 AHuier的 <a href="http://blog.csdn.net/xukunhui2/article/details/17013647" target="_blank" rel="external">Handler 中 sendMessage() 源代码剖析</a></p>
<ol>
<li><p>使用Handler中的sendEmptyMessage(int what)方式来发送消息.</p>
<p>sendEmptyMessage (int what)</p>
</li>
</ol>
<p>——&gt; sendEmptyMessageDelayed(int what, long delayMillis)</p>
<p>——&gt;sendMessageDelayed(Message msg, long delayMillis)  </p>
<p>——&gt;sendMessageAtTime(Message msg, long uptimeMillis)  </p>
<p>——&gt;enqueueMessage(Message msg, long when)</p>
<ol>
<li>使用Handler中的sendEmptyMessageAtTime(int what,long uptimeMillis)方式来发送消息.</li>
</ol>
<p>sendEmptyMessageAtTime(int what,long uptimeMillis)</p>
<p>——&gt;sendMessageAtTime(msg, uptimeMillis)</p>
<ol>
<li>使用Handler中的sendEmptyMessageDelayed (int what, long delayMillis)方式来发送消息。</li>
</ol>
<p>sendEmptyMessageDelayed(int what, long delayMillis) </p>
<p>——&gt;sendMessageDelayed(Message msg, long delayMillis) </p>
<p>——&gt;sendMessageAtTime(Message msg, long uptimeMillis)</p>
<pre><code class="shell">public final boolean sendMessageDelayed(Message msg, long delayMillis)  
{  
    if (delayMillis &lt; 0) {  
        delayMillis = 0;  
    }  
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); 
}
</code></pre>
<p>SystemClock.uptimeMillis() 是获得到系统启动开机的时间到当前的时间（不包括休眠的时间）</p>
<p>SystemClock.uptimeMillis() + delayMillis 这个是sendMessageAtTime 和 sendMessageDelayed 的区别。</p>
<ol>
<li>使用Handler中的sendMessage (Message msg)方式来发送消息.</li>
</ol>
<p>sendMessage(Message msg) </p>
<p>——&gt; sendMessageDelayed(Message msg, long delayMillis) </p>
<p>——&gt; sendMessageAtTime(Message msg, long uptimeMillis)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Handler中sendMessage源代码剖析。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://nijun.me/categories/Android/"/>
    
    
      <category term="Android" scheme="http://nijun.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Activity的生命周期和启动模式</title>
    <link href="http://nijun.me/2017/06/08/00001-Android-2017-06-08-Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://nijun.me/2017/06/08/00001-Android-2017-06-08-Activity的生命周期和启动模式/</id>
    <published>2017-06-07T16:05:40.000Z</published>
    <updated>2017-07-13T15:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android中我们最先接触到的就是Activity，如果掌握了 Activity，那么对学习其他四大组件无疑是很有帮助的。</p>
<a id="more"></a>
<h1 id="Activity-的生命周期"><a href="#Activity-的生命周期" class="headerlink" title="Activity 的生命周期"></a>Activity 的生命周期</h1><p><img src="http://osoa5juml.bkt.clouddn.com/image/site/1499949623365.png" alt=""></p>
<h2 id="情形一"><a href="#情形一" class="headerlink" title="情形一"></a>情形一</h2><p>例如：运行一个 Activity ，不进行任何的页面跳转，然后按下返回键结束。</p>
<pre><code class="shell">05-30 12:00:44.864 3561-3561/me.nijun.launchmode I/AActivity: onCreate: A
05-30 12:00:44.864 3561-3561/me.nijun.launchmode I/AActivity: onStart: A
05-30 12:00:44.864 3561-3561/me.nijun.launchmode I/AActivity: onResume: A
05-30 12:00:44.864 3561-3561/me.nijun.launchmode I/AActivity: onPause: A
05-30 12:00:44.864 3561-3561/me.nijun.launchmode I/AActivity: onStop: A
05-30 12:00:44.864 3561-3561/me.nijun.launchmode I/AActivity: onDestory: A
</code></pre>
<h2 id="情形二"><a href="#情形二" class="headerlink" title="情形二"></a>情形二</h2><p>（1）当第一次启动 A Activity 的时候，会按照下面的顺序执行。</p>
<pre><code class="shell">05-30 12:00:44.864 3561-3561/me.nijun.launchmode I/AActivity: onCreate: A
05-30 12:00:44.864 3561-3561/me.nijun.launchmode I/AActivity: onStart: A
05-30 12:00:44.864 3561-3561/me.nijun.launchmode I/AActivity: onResume: A
</code></pre>
<p><code>onStart</code> 的时候 Activity 还在后台，<code>onResume</code> 的时候才会显示到前台。</p>
<p>（2）这时候点击按钮启动 B Acitivity 的时候</p>
<pre><code class="Shell">05-30 12:00:56.869 3561-3561/me.nijun.launchmode I/AActivity: onPause: A
05-30 12:21:03.756 4030-4030/me.nijun.launchmode I/BActivity: onCreate: B
05-30 12:00:56.882 3561-3561/me.nijun.launchmode I/BActivity: onStart: B
05-30 12:00:56.883 3561-3561/me.nijun.launchmode I/BActivity: onResume: B
05-30 12:00:57.310 3561-3561/me.nijun.launchmode I/AActivity: onSaveInstanceState: A
05-30 12:00:57.312 3561-3561/me.nijun.launchmode I/AActivity: onStop: A
</code></pre>
<p>可见，首先调用旧Activity的 <code>onpause</code> 方法，<code>onpause</code> 一定在要启动的新 Activity 之前执行，只有它执行完之后，新的 Activity 才会启动。正因为如此，我们在 onPause方法中不能重量级的操作，应当在 onStop 中处理操作，使新 Activity 尽快显示出来。</p>
<p><code>onSaveInstanceState</code> 方法会在 <code>onStop</code> 方法之前执行，但具体是否在<code>onPause</code> 之前还是之后是不确定的。</p>
<p><code>onStop</code> 方法是否执行是看 Activity 是否可见，如果用户回到桌面（不可见了），那么就会调用这个方法。但是如果如果调用新的 Activity 采用了新透明的主题，那么是<strong>不会调用<code>onStop</code></strong> 方法的。</p>
<p>（3）当用户按下返回键的时候</p>
<p> 这时候 BAcitivity 将被销毁。在 <code>onPause</code> 执行后，并不会直接执行 <code>onStop</code> 而是会先执行 AActivity 的 onRestart 、onStart、onResume 方法。</p>
<pre><code class="shell">05-30 12:21:11.422 4030-4030/me.nijun.launchmode I/BActivity: onPause: B
05-30 12:21:11.433 4030-4030/me.nijun.launchmode I/AActivity: onRestart: A
05-30 12:21:11.433 4030-4030/me.nijun.launchmode I/AActivity: onStart: A
05-30 12:21:11.433 4030-4030/me.nijun.launchmode I/AActivity: onResume: A
05-30 12:21:11.764 4030-4030/me.nijun.launchmode I/BActivity: onStop: B
05-30 12:21:11.765 4030-4030/me.nijun.launchmode I/BActivity: onDestroy: B
</code></pre>
<p>（4）当Activity被系统回收后再次打开，生命周期回调方法和 （1）一样，但是不是所有过程都一样。</p>
<p>小结：</p>
<ol>
<li>onCreate 和 onDestory 是配对的，代表这创建和销毁。</li>
<li>onStart 和 onStop 是配对的，代表着 Activity 是否可见。</li>
<li>onResume 和 onPause 是配对的，代表的 Activity 是否在前台。</li>
<li>A Activity 的生命周期：<ol>
<li>A 被 B 完全遮挡住了：onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onRestart-&gt;onStart-&gt;onResume。</li>
<li>A 被 B 部分遮挡住了：onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onResume。</li>
</ol>
</li>
</ol>
<h2 id="情形三"><a href="#情形三" class="headerlink" title="情形三"></a>情形三</h2><p>我们启动 Activity 之后，然后点击按钮弹出 AlertDialog 。</p>
<p>Activity 的启动过程：onCreate-&gt;onStart-&gt;onResume</p>
<p>因为当启动和退出 Dialog 的时候 ，Activity 的状态始终没有改变。这样看来，Dialog 是 Activity 内部的界面，不会影响到 Activity 的生命周期。</p>
<h2 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h2><p>（1）相关资源的配置发生改变导致 Activity 被杀死并重新创建。</p>
<p>例子：比如用户转换屏幕，从竖屏切换到横屏。</p>
<p>这时候Activity被销毁，其 onPause、onStop、onDestroy都会被调用。这个过程中也会调用 onSaveInstanceState 方法来保存当前Activity的状态，这个方法会在onStop之前执行，顺序与onPause无关。注意：在正常情况下是不会调用这个方法的。</p>
<p>当Activity重新创建后，系统会调用 onRestoreInstanceState 方法，并把 onSaveInstanceState 保存的 Bundle 对象传递给onRestoreInstanceState和onCreate方法。</p>
<p>从时序上看，onRestoreInstanceState 会在 onStart 方法之后调用。</p>
<pre><code class="java">05-30 12:34:27.247 4030-4030/me.nijun.launchmode I/AActivity: onPause: A
05-30 12:34:27.247 4030-4030/me.nijun.launchmode I/AActivity: onSaveInstanceState: A
05-30 12:34:27.249 4030-4030/me.nijun.launchmode I/AActivity: onStop: A
05-30 12:34:27.249 4030-4030/me.nijun.launchmode I/AActivity: onDestroy: A
05-30 12:34:27.262 4030-4030/me.nijun.launchmode I/AActivity: onCreate:  A
05-30 12:34:27.262 4030-4030/me.nijun.launchmode I/AActivity: onStart: A
05-30 12:34:27.262 4030-4030/me.nijun.launchmode I/AActivity: onRestoreInstanceState: restore extra_test test
05-30 12:34:27.263 4030-4030/me.nijun.launchmode I/AActivity: onResume: A

  public void main(){

  }
</code></pre>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>View 与 Activity 一样，也有 onSaveInstanceState 和 onRestoreInstanceState 两个方法。</p>
<p>关于保存和恢复View层次结构，系统的工作流程是这样的：首先Activity 在异常中止的情况下，会调用 onSaveInstanceState 去保存数据。 Activity 会委托 Window 去保存数据，Window再委托他上面的顶层容器去保存。顶层容器是一个ViewGroup，一般来说是 DecorView。顶层容器再去一一通知它的子元素去保存数据。</p>
<p>这是一种典型的委托思想，上层委托下层，父容器委托子元素去处理意见事情。这在Android中有很多实现，比如<strong>View的绘制过程、事件分发</strong>。</p>
<p>onSaveInstanceState 只会在 Activity 即将销毁并且有机会重新显示的情况下才会去调用。</p>
<h3 id="还有一点"><a href="#还有一点" class="headerlink" title="还有一点"></a>还有一点</h3><p>onRestoreInstanceState 和 onCreate 的区别：</p>
<p>onRestoreInstanceState 一旦被调用，其参数 Bundle 一定有值，而onCreate在正常启动的时候其参数Bundle为null。</p>
<p>官方推荐：使用 <strong>onRestoreInstanceState</strong> 去恢复保存的数据。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>如果不想要系统重新创建 Activity的话，可以指定在 AndroidManifest.xml 中指定 android:configChanges 的属性。</p>
<p>最好是加上 orientation|screenSize|keyboardHidden 这三个值，因为 Android 13 （ API13 ）之后，screen size 也会跟着屏幕横竖屏切换而改变。可以设置下列语句</p>
<pre><code>android:configChanges=&quot;orientation|screenSize|keyboardHidden&quot;
</code></pre><h1 id="Activity-的LaunchMode"><a href="#Activity-的LaunchMode" class="headerlink" title="Activity 的LaunchMode"></a>Activity 的LaunchMode</h1><p>路漫漫其修远兮，吾将上下而求索。—屈原《离骚》</p>
<p>今天，花了一个晚上的时间整理了一下 Activity 的 LaunchMode 启动模式。既然下定决心要走这一行，那么就从最基础的开始学起。</p>
<p>在 Android 中，一共由四种启动模式，分别是</p>
<ol>
<li>standard</li>
<li>singleTop</li>
<li>singleTask</li>
<li>singleInstance</li>
</ol>
<p>这里，我把这四个分成两组。</p>
<p>其中，<code>standard</code>  和 <code>singleTop</code> Activity 为一类，使用 <code>standard</code> 或 <code>singleTop</code> 启动模式的 Activity 可多次实例化。可以属于任何任务栈，并且可以位于活动堆栈的任何位置。但是通常，它们被启动到所调用的任务中栈中。</p>
<p>其中，standard 模式很简单，调用几次就创建几次。singleTop 与之类似，不同在于如果要启动的 Activity 已经在栈顶了，那么就不创建直接复用，并且调用 onNewIntent 方法。如果一个现有实例虽在目标任务内，但未处于堆栈顶部，或者虽然位于堆栈顶部，但不在目标任务中 — 则系统会创建一个新实例并将其推送到堆栈上。</p>
<p><code>singleTask</code> 和 <code>singleInstance</code> 为另一类。<code>singleTask</code> 和 <code>singleInstance</code> Activity 只能启动任务。 它们始终位于 Activity 堆栈的<strong>栈顶</strong>，并且每个栈中只能有一个相同的 Activity 。</p>
<p>singleTask 和 singleInstance 同样只在一个方面有差异。 singleTask 允许其他 Activity 成为其任务（必然是 standard 和 singleTask 的 Activity ）的组成部分，它始终位于其任务的根位置。singleInstance 不允许其他 Activity 成为其任务的组成部分。它是任务中唯一的 Activity。 如果它启动另一个 Activity，系统会将该 Activity 分配给其他任务 — 就好像 Intent 中包含 <code>FLAG_ACTIVITY_NEW_TASK</code> 一样。</p>
<p>我自己做了一个实验。分别创建两个程序，一个叫做 LaunchMode，有 Activity A 和 Activity B，另一个叫做 LaunchModeB，有 Activity C 和 Activity D。在 Android 6.0 上运行。</p>
<ul>
<li>情形一</li>
</ul>
<p>前置条件：LaunchMode中从 A 启动 B（这时任务栈是 B-&gt;A），LaunchModeB 从 C 启动 D（这时任务栈是 D-&gt;C），这时我想从 B 中 启动 C 和 Ｄ，其中 C 和 D 都是standard 模式。</p>
<p>结果：在 B 中启动 C 后（这时任务栈是 C-&gt;B-&gt;A），C 从当前 Activity 右侧出现，按下 back 键直接向右侧消失。D 也是这个情况。</p>
<p>首先，从右侧出现代表没有切换到其他的应用程序，而我们知道 C 和 D Activity 是 LaunchModeB 中的 Activity。那为什么不是打开 LaunchModeB 之后再启动 C Activity 呢？这时因为设置了 standard 这个启动模式，在这个例子中当前程序并没有创建新得任务栈，而是在 B Activity 所在的任务栈中将 C Activity 启动并加入其中。也就是说被启动的 Activity 会被加入到启动它的 Activity 中。</p>
<ul>
<li>情形二</li>
</ul>
<p>前置条件：LaunchMode中从 A 启动 B（这时任务栈是 B-&gt;A），LaunchModeB 从 C 启动 D（这时任务栈是 D-&gt;C ，我想从 B 中 启动 C 和 Ｄ，其中 C 是 standard 模式 ，D 都是 singleTask 模式。</p>
<p>结果：我在 B Activity 中点击启动 C ，这时和情形一是一样的，这里不讨论了。而如果点击启动 D 之后，系统发现在现有任务栈中已经有了 D Activity，这时候会并不会去创建新的，而是直接切换到 D Activity 所在的任务栈，这时候按下 back 键，将回退到 C Activity 中，再次按下 back 键，就销毁了LaunchModeB 中的任务栈。这时候再次在 B 中启动 D，这时候系统发现在任务栈中没有已有的 D，就会创建 D，并加入到新的任务栈中（这时任务栈是 D），按下 back 键就会直接销毁 Ｄ返回到 B Activity。</p>
<ul>
<li>情形三</li>
</ul>
<p>前置条件：LaunchMode中从 A 启动 B（这时任务栈是 B-&gt;A），LaunchModeB 从 C 启动 D（这时任务栈是 D-&gt;C ，我想从 B 中 启动 C 和 Ｄ，其中 C 是 singleTask 模式 ，D 都是 standard 模式。</p>
<p>结果：从 B 点击按钮打开 C （这时任务栈是 C ），singleTask 因为有 clearTop 的效果而被推出任务栈。在 C Activity 中再次打开 D Activity，不要按 back 键，选择任务返回到 B Activity，点击按钮打开 D Activity（这时任务栈是 D-&gt;B-&gt;A），发现动画效果是从右侧进入，断定此时这个 D Activity 所在的任务栈是 B Activity 所在的任务栈，因此这时按下 back 键，就不会返回到 C Activity，而是返回到 B Activity。</p>
<p>还有一点需要注意，当我从 C 中启动 D 之后，按下 Home 键返回桌面，在从桌面图标点击进入程序，发现进入的是 C Activity，而不是 D Activity。原因还是 C Activity 是 singleTask 模式。</p>
<ul>
<li>情形四</li>
</ul>
<p>还是上面的前置条件，但是 C 和 D 都是 singleTask 模式。情况与情形三类似，只是在打开 D Activity 的时候（这时任务栈是 D-&gt;C），当前任务栈转移到了 LaunchModeB 程序中，相当于打开了 LaunchMode 这个程序，而这时栈顶是 D ，所以出现的是 D Activity，按下返回键跳转到 C Activity。</p>
<p>另一种情况是在 Intent 中设置标志位来为 Activity 指定启动模式。这种方式优先于 AndroidManifest 中配置的方式，当两种同时存在时，以第二种方式为准。然后它们在限定范围上有所不同，第一种方式无法设置  FLAG_ACTIVITY_CLEAR_TOP 标志，而第二种方式无法指定 singleInstance 模式。</p>
<p><strong>FLAG_ACTIVITY_NEW_TASK</strong> </p>
<p>等同于 “singleTask” 。在这种情况下，被启动的 Activity 的实例如果已经存在，那么系统会调用他的 onNewIntent ，而不会去调用 onCreate 。但是不要忘记，系统可能会杀掉后台运行的 Activity，如果这一切发生，那么系统就会调用 onCreate 方法，而不调用 onNewIntent 方法，一个好的解决方法就是在 onCreate 和 onNewIntent 方法中调用同一个处理数据的方法。</p>
<p><strong>FLAG_ACTIVITY_SINGLE_TOP</strong></p>
<p>等同于 “singleTop” 。</p>
<p><strong>FLAG_ACTIVITY_CLEAR_TOP</strong></p>
<p>等同于 “singleTop” 。</p>
<p>在 Android Studio 中可以使用 <code>adb shell dumpsys activity</code> 来查看任务栈和 <code>taskAffinity</code> 的值。</p>
<p> <a href="http://android.xsoftlab.net/guide/topics/manifest/activity-element.html#aff" target="_blank" rel="external">taskAffinity</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android中我们最先接触到的就是Activity，如果掌握了 Activity，那么对学习其他四大组件无疑是很有帮助的。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://nijun.me/categories/Android/"/>
    
    
      <category term="Android" scheme="http://nijun.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>maven学习总结</title>
    <link href="http://nijun.me/2017/05/20/00001-maven-2017-05-20-maven/"/>
    <id>http://nijun.me/2017/05/20/00001-maven-2017-05-20-maven/</id>
    <published>2017-05-20T05:32:40.000Z</published>
    <updated>2017-07-13T13:06:01.000Z</updated>
    
    <content type="html"><![CDATA[ <div align="center"><br>  想学习Maven吗？<br><br></div>

<a id="more"></a>
<h1 id="常用的构建命令"><a href="#常用的构建命令" class="headerlink" title="常用的构建命令"></a>常用的构建命令</h1><p>mvn </p>
<ul>
<li>v 查看版本</li>
</ul>
<ul>
<li>compile 编译</li>
</ul>
<ul>
<li>test 测试</li>
</ul>
<ul>
<li>package  打包<ul>
<li>会依次执行  clean 、</li>
</ul>
</li>
<li>clean 删除target文件夹</li>
<li>Install 安装jar包到本地仓库中</li>
</ul>
<h1 id="自动创建目录骨架"><a href="#自动创建目录骨架" class="headerlink" title="自动创建目录骨架"></a>自动创建目录骨架</h1><p>创建目录的两种方式：</p>
<ol>
<li>mvn archetype:generate 按照提示进行选择</li>
</ol>
<ol>
<li><p>mvn archetype:generate -DgroupId=组织名，公司网址的反写+项目名</p>
<p>​                        -DartifactId=项目名-模块名</p>
<p>​                        -Dversion=版本号</p>
<p>​                        -Dpackage=代码所在的包名</p>
</li>
</ol>
<p>src/main/java:存放java源文件</p>
<p>src/main/resources:存放项目配置文件，如spring.xml,hibernate.cfg.xml。。。</p>
<p>src/test/java:存放test的java文件</p>
<p>src/test/resources:存放test时候所需的配置文件</p>
<h1 id="maven中的坐标和仓库"><a href="#maven中的坐标和仓库" class="headerlink" title="maven中的坐标和仓库"></a>maven中的坐标和仓库</h1><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>在<code>&lt;dependency&gt;</code>中的就是坐标</p>
<pre><code class="Xml">  &lt;dependency&gt;
    &lt;groupId&gt;com.nimon.maven01&lt;/groupId&gt;
    &lt;artifactId&gt;maven01-model&lt;/artifactId&gt;  
    &lt;version&gt;0.0.1SNAPSHOT&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre>
<blockquote>
<p>项目的包名，建议和groupId和artifactId相吻合，这样看起来，就更加清晰，符合逻辑，也更方便搜索。</p>
</blockquote>
<h2 id="构件"><a href="#构件" class="headerlink" title="构件"></a>构件</h2><p>在maven世界中，任何一个依赖、插件、项目构建的输出，都可以被称作为<strong>构件</strong>。</p>
<p><strong>构件</strong>通过坐标作为其唯一的标识，就好像我们的工作单位和家庭地址。</p>
<blockquote>
<p>收宝贝的时候，不是收到的那一刻，而是中间等待的过程。</p>
</blockquote>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>​    本地仓库和远程仓库</p>
<p>​    <a href="http://search.maven.org/" target="_blank" rel="external">查看仓库</a></p>
<p>​    <a href="https://repo.maven.apache.org/maven2/" target="_blank" rel="external">全球中央仓库</a></p>
<p>​    <a href="http://mvnrepository.com/" target="_blank" rel="external">MVN Repository</a></p>
<h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><blockquote>
<p>一旦配置了镜像，那么所有访问都会到镜像仓库中，原仓库将不能直接访问。</p>
<p>maven主目录 &gt; conf &gt; settings.xml &gt; 146行</p>
</blockquote>
<pre><code class="Xml">    &lt;mirror&gt;
      &lt;id&gt;maven.net.cn&lt;/id&gt;
      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
      &lt;name&gt;Central mirror in china&lt;/name&gt;
      &lt;url&gt;http://maven.net.cn/content/groups/public&lt;/url&gt;
    &lt;/mirror&gt;
</code></pre>
<h2 id="更改仓库位置"><a href="#更改仓库位置" class="headerlink" title="更改仓库位置"></a>更改仓库位置</h2><blockquote>
<p>maven从远程中央仓库下载默认是存放在当前用户目录中</p>
<p>​    即 ~/.m2/repository</p>
</blockquote>
<p>修改 <code>settings.xml</code>文件，复制第 53 行的内容</p>
<pre><code> &lt;localRepository&gt;/Users/nimon/nj/proj/maven/repo&lt;/localRepository&gt;
</code></pre><p>其中路径表示新仓库的位置。然后复制一份 <code>settings.xml</code>  到 <code>repo</code> 目录下，这样我们以后更新maven版本就不用再修改原始的 <code>settings.xml</code></p>
<h1 id="maven的生命周期和插件"><a href="#maven的生命周期和插件" class="headerlink" title="maven的生命周期和插件"></a>maven的生命周期和插件</h1><h2 id="完整的项目构建过程包括"><a href="#完整的项目构建过程包括" class="headerlink" title="完整的项目构建过程包括"></a>完整的项目构建过程包括</h2><p>清理、编译、测试、打包、集成测试、验证、部署</p>
<p>maven将其进行抽象。实际上，maven和插件是密不可分的，maven抽象出一套项目构建的生命周期，而插件是对maven抽象的具体实现。</p>
<p>比如，我们对项目进行编译，</p>
<h2 id="maven中定义了三套独立的生命周期"><a href="#maven中定义了三套独立的生命周期" class="headerlink" title="maven中定义了三套独立的生命周期"></a>maven中定义了三套独立的生命周期</h2><ol>
<li>clean    清理项目</li>
<li>default  构建项目</li>
<li>site   生成项目站点</li>
</ol>
<p>这三套生命周期是相互独立的，每个生命周期又包含一些阶段，这些阶段是有顺序的，后面的阶段依赖于前面的阶段。在执行的时候，前面的阶段会顺序执行，并不会触发另外两个生命周期中的阶段。</p>
<h3 id="clean-清理项目阶段"><a href="#clean-清理项目阶段" class="headerlink" title="clean 清理项目阶段"></a>clean 清理项目阶段</h3><p>pre-clean 执行清理前的工作</p>
<p>clean 清理上一次构建的文件</p>
<p>post-clean 执行清理后的文件</p>
<h3 id="default-构建项目（最核心）"><a href="#default-构建项目（最核心）" class="headerlink" title="default 构建项目（最核心）"></a>default 构建项目（最核心）</h3><p>compile test package install</p>
<h3 id="site-生成项目站点"><a href="#site-生成项目站点" class="headerlink" title="site 生成项目站点"></a>site 生成项目站点</h3><p>pre-site 在生成项目站点前要完成工作</p>
<p>site  生成项目的站点文档</p>
<p>post-site  在生成项目站点后要完成的工作</p>
<p>site-deploy  发布生成的站点到服务器</p>
<p>可以去 <strong><a href="https://maven.apache.org/plugins" target="_blank" rel="external">官方插件</a></strong> ，查找使用插件</p>
<h1 id="pom-xml常用元素"><a href="#pom-xml常用元素" class="headerlink" title="pom.xml常用元素"></a>pom.xml常用元素</h1><p>pom.xml是maven项目的核心管理文件，用于项目描述、组织管理、依赖管理和构建信息的管理。 </p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;   

    &lt;groupId&gt;组织名，公司网址的反写+项目名&lt;/groupId&gt;
    &lt;artifactId&gt;项目名-模块名&lt;/artifactId&gt;
      &lt;!--打包类型，默认是jar
        war zip pom    
    --&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;
      &lt;!--第一个0表示大版本号
    第二个0 表示分支版本号
    第三个0 表示小版本号
    SNAPSHOT ：不稳定，尚处于开发中，快照版本
    ALPHA ：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。
    Beta：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。
    RELEASE ：稳定版
    GA ：正式发布
    --&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;!--项目描述名--&gt;
    &lt;name&gt;maven05-demo Maven Webapp&lt;/name&gt;
      &lt;!--项目地址--&gt;
    &lt;url&gt;http://maven.apache.org&lt;/url&gt;
    &lt;!--项目描述--&gt;
    &lt;description&gt;&lt;/description&gt;
      &lt;developers&gt;&lt;/developers&gt;
      &lt;licenses&gt;&lt;/licenses&gt;
      &lt;organization&gt;&lt;/organization&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.10&lt;/version&gt;
              &lt;!--只存在于测试的 classpath 中--&gt;
            &lt;scope&gt;test&lt;/scope&gt;
              &lt;type&gt;&lt;/type&gt;
              &lt;!--设置依赖是否可选--&gt;
              &lt;optional&gt;&lt;/optional&gt;
              &lt;!--排除依赖传递列表--&gt;
              &lt;exclusions&gt;
                  &lt;exclusion&gt;

                  &lt;/exclusion&gt;
              &lt;/exclusions&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

      &lt;!--依赖的管理，不会被运行和引入到实际的依赖中--&gt;
      &lt;dependencyManagerment&gt;
          &lt;!--主要定义在父模块中，供子模块集成用的--&gt;
          &lt;dependency&gt;

          &lt;/dependency&gt;
      &lt;/dependencyManagerment&gt;

      &lt;!--插件列表--&gt;
       &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.4&lt;/version&gt;
                  &lt;!--上面三项是坐标--&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;

            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.0.2&lt;/version&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
        &lt;!--子模块对父模块的继承--&gt;
           &lt;parent&gt;&lt;/parent&gt;
        &lt;!--聚合多个maven运行项--&gt;
           &lt;modules&gt;&lt;/modules&gt;

        &lt;finalName&gt;maven05-demo&lt;/finalName&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<h1 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h1><p>我们平时在开发时，如果要使用某一个框架，就需要把框架的jar包引入项目的 classpath 中，这样我们的项目就可以使用 框架为我们封装好的一些方法。maven给我们提供了三种classpath：</p>
<ol>
<li>编译</li>
<li>测试 test</li>
<li>运行  </li>
</ol>
<p>所以依赖的范围就是控制依赖于三种 classpath 的关系的。</p>
<p>有六中依赖范围的值可以选择：</p>
<ul>
<li>compile 默认的范围，如果没有明确指定，编译依赖将在所有的 classpath 中都有效，而且会传递到依赖项目中。</li>
<li>provided  在编译和测试的时候有效</li>
<li>runtime 在测试和运行时有效</li>
<li>test 只在测试的时候有效</li>
<li>system 于本机系统相关联，可移植性差</li>
<li>import 导入的范围，它只使用在 dependencyManagerment ，表示从其他 pom 中导入的 dependency 的配置。</li>
</ul>
<p>例如</p>
<pre><code class="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;maven&lt;/groupId&gt;
  &lt;artifactId&gt;B&lt;/artifactId&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;name&gt;B&lt;/name&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;maven&lt;/groupId&gt;
        &lt;artifactId&gt;A&lt;/artifactId&gt;
        &lt;version&gt;1.0&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;scope&gt;import&lt;/scope&gt;
      &lt;/dependency&gt;
      .....
</code></pre>
<h1 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h1><p>一个小案例</p>
<p>shanji 依赖于 nage</p>
<p>nage 依赖于 bge</p>
<p>bge的依赖关系</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.10&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
 &lt;/dependencies&gt;
</code></pre>
<p>nage的依赖关系</p>
<pre><code class="xml">&lt;dependencies&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;com.hongxing&lt;/groupId&gt;
      &lt;artifactId&gt;hongxing-bge&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;

  &lt;/dependencies&gt;
</code></pre>
<p>shanji的依赖关系</p>
<pre><code class="Xml">&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;com.hongxing&lt;/groupId&gt;
      &lt;artifactId&gt;hongxing-nage&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;com.hongxing&lt;/groupId&gt;
          &lt;artifactId&gt;hongxing-bge&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre>
<p>这时候nage下就有bge的依赖jar包，shanji下有bge和nage的依赖jar包。</p>
<p>但是由于依赖的传递性，shanji 只依赖于nage ，shanji 项目中会出现 bge 的jar包。有时候，这不是我们想要的。</p>
<p>这时可以在 nage 依赖下使用 <exclusions>  把 bge 排除在外。</exclusions></p>
<h1 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h1><blockquote>
<p>eg 对不同版本的同一个构建。</p>
</blockquote>
<ol>
<li><p>短路优先</p>
<p>A -&gt; B -&gt; C -&gt; X（JAR)</p>
<p>A -&gt; D -&gt; X（JAR)    <strong>优先</strong></p>
</li>
</ol>
<p>举例：</p>
<p>在 bge 中添加commons-io 2.5的版本依赖</p>
<p>在 nage 中添加commons-io 2.0的版本依赖</p>
<p>这时候在 shanji 项目中就会出现 2.0 的版本，因为shanji 离 nage 比较近。</p>
<ol>
<li>先声明先优先</li>
</ol>
<p>如果路径长度相同，谁先声明，先解析谁。</p>
<p>举例：</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;com.hongxing&lt;/groupId&gt;
      &lt;artifactId&gt;hongxing-bge&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;com.hongxing&lt;/groupId&gt;
      &lt;artifactId&gt;hongxing-nage&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;!--&lt;exclusions&gt;--&gt;
        &lt;!--&lt;exclusion&gt;--&gt;
          &lt;!--&lt;groupId&gt;com.hongxing&lt;/groupId&gt;--&gt;
          &lt;!--&lt;artifactId&gt;hongxing-bge&lt;/artifactId&gt;--&gt;
        &lt;!--&lt;/exclusion&gt;--&gt;
      &lt;!--&lt;/exclusions&gt;--&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre>
<p>这时候，项目中 commons-io 的版本就变成了 2.5，因为是先声明 bge ，后声明 nage 。</p>
<h1 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h1><p>如果在maven中有多个项目，我们想要 install 将其放到本地仓库中， 必须对其依次执行 install 命令</p>
<p>maven 给我提供了一个解决办法，就是使用 <strong>聚合</strong> </p>
<pre><code class="xml">&lt;modules&gt;
  &lt;module&gt;../hongxing-bge&lt;/module&gt;
  &lt;module&gt;../hongxing-nage&lt;/module&gt;
  &lt;module&gt;../hongxing-shanji&lt;/module&gt;
&lt;/modules&gt;
</code></pre>
<p>然后执行 install 命令，就会自动把三个module都安装到本地仓库中了。</p>
<p>定义父容器</p>
<pre><code class="xml">      &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;junit.version&gt;
            3.8.1
        &lt;/junit.version&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;junit&lt;/groupId&gt;
                &lt;artifactId&gt;junit&lt;/artifactId&gt;
                &lt;version&gt;${junit.version}&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
</code></pre>
<p>然后在子类中使用</p>
<pre><code class="xml">  &lt;parent&gt;
    &lt;groupId&gt;com.hongxing&lt;/groupId&gt;
    &lt;artifactId&gt;hongxing-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
</code></pre>
<blockquote>
<p>注意修改  <strong><packaging></packaging></strong> 为pom</p>
</blockquote>
<h1 id="使用maven构建web项目"><a href="#使用maven构建web项目" class="headerlink" title="使用maven构建web项目"></a>使用maven构建web项目</h1><p>Next，这里在Properties中添加一个参数<code>archetypeCatalog=internal</code>，不加这个参数，在maven生成骨架的时候将会非常慢，有时候会直接卡住。</p>
<p>来自网上的解释：</p>
<blockquote>
<p>archetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据，由于中央仓库的archetype太多了，所以导致很慢，指定internal来表示仅使用内部元数据。</p>
</blockquote>
<p><img src="http://osoa5juml.bkt.clouddn.com//image/site/1499951126858.png" alt=""></p>
<p>使用 jetty 发布</p>
<pre><code class="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
  &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;9.4.4.v20170414&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;!--在打包成功后使用jetty:run来运行jetty服务--&gt;
      &lt;phase&gt;package&lt;/phase&gt;  &lt;!--指定在package阶段的时候--&gt;
      &lt;goals&gt;
        &lt;goal&gt;run&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;  想学习Maven吗？&lt;br&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="maven" scheme="http://nijun.me/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 学习之路</title>
    <link href="http://nijun.me/2017/05/14/00001-Git-2017-05-14-GitHub-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <id>http://nijun.me/2017/05/14/00001-Git-2017-05-14-GitHub-学习之路/</id>
    <published>2017-05-14T13:55:29.000Z</published>
    <updated>2017-07-13T12:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://osoa5juml.bkt.clouddn.com/image/site/1499949527648.png" alt=""></p>
<div align="center"><br><br>自学 Git 的一些总结<br><br></div>

<a id="more"></a>
<blockquote>
<p>成大事不在于力量的大小，而在于能坚持多久。              ——约翰生</p>
</blockquote>
<h1 id="Git配置多个SSH"><a href="#Git配置多个SSH" class="headerlink" title="Git配置多个SSH"></a>Git配置多个SSH</h1><p>在日常开发中，我们可能会使用多个帐号以及多个  SSH-Key ，可能是 <a href="https://git.oschina.net/" target="_blank" rel="external">码云</a>，也可能是 <a href="https://github.com/" target="_blank" rel="external">GitHub</a> ，如果你的电脑中只配置了一个 SSH-Key ，那到时候另一个或多个帐号在使用上，就会带来些许不便。（你能忍受每次 push 都要求你输入密码吗？或者每次切换帐号都需要重新配置 SSH-Key 吗？因为每次使用默认配置的方法都会将前一次配置覆盖。），作为程序员，怎么能让这种事情发生呢，我们需要一种一劳永逸的解决办法。经过上网搜索及筛选，我找到一种比较简单方便的方法。</p>
<h2 id="1-生成并添加第一个SSH"><a href="#1-生成并添加第一个SSH" class="headerlink" title="1. 生成并添加第一个SSH"></a>1. 生成并添加第一个SSH</h2><p>首先你得安装 <a href="https://git-scm.com/" target="_blank" rel="external">git</a> 客户端。Windows 平台，安装完后，在桌面右键选择 git bash 打开。Mac 平台安装好，打开 Terminal 或者 iTerm 输入以下命令。</p>
<pre><code class="Java">$ ssh-keygen -t rsa -C &quot;youremail@xxx.com&quot;
</code></pre>
<p>在 Git Bash 中执行命令一路回车，会在 ~/.ssh/ 目录下生成 id_rsa 和 id_rsa.pub 两个文件用文本编辑器打开 id_rsa.pub 里的内容，在 Github 中添加 SSH Keys</p>
<h2 id="2-生成并添加第二个SSH"><a href="#2-生成并添加第二个SSH" class="headerlink" title="2. 生成并添加第二个SSH"></a>2. 生成并添加第二个SSH</h2><p>接着上一步，为了区分开不同的 SSH-Key，我在生成文件的时候用了不同的名称来区分。 输入你要配置的另一个 SSH-Key 的邮箱。</p>
<pre><code class="shell">$ ssh-keygen -t rsa -C &quot;otheremail@xxx.com&quot;
</code></pre>
<p>这次不要一路回车，请输入这个文件的名字，见下面的第三行。</p>
<pre><code class="Shell">$ ssh-keygen -t rsa -C &quot;824291045@qq.com&quot;
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/nimon/.ssh/id_rsa): other
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in other.
Your public key has been saved in other.pub.
The key fingerprint is:
SHA256:tlHc9GiN8cLngDw8QmomMlxmc+2odsRciMjIu6ljjzQ 824291045@qq.com
The key&#39;s randomart image is:
+---[RSA 2048]----+
|.o .=..o.   o    |
|.oo+.o.oo+ = B   |
</code></pre>
<p>如上输入 <code>other</code>  之后会在.ssh目录下生成两个文件 <code>other</code> 和 <code>other.pub</code> ，原理同步骤1。</p>
<h2 id="3-创建config文件"><a href="#3-创建config文件" class="headerlink" title="3.创建config文件"></a>3.创建config文件</h2><p>因为 SSH-Key 有一个默认的配置，如果我们还是按照默认配置，那么注定是不会成功的。</p>
<p>我们需要在 ~/.ssh 目录下添加 config 配置文件用于区分多个 SSH-Key 。</p>
<pre><code class="tex">Host github.com  
    HostName github.com  
    PreferredAuthentications publickey  
    IdentityFile ~/.ssh/id_rsa  

Host other.github.com  
    HostName github.com  
    PreferredAuthentications publickey  
    IdentityFile ~/.ssh/other
</code></pre>
<p>之后保存并推出编辑器。</p>
<ul>
<li>Host : 代表一个映射的域名地址，可以自己取。</li>
<li>HostName ： 是实际的域名地址，一般是代码托管平台的域名。</li>
<li>PreferredAuthentications ： 配置登录时用什么权限认证，可设为<code>publickey,password publickey,keyboard-interactive</code>，在这里使用 publickey 即可。</li>
<li>IdentityFile ： 就是更改生成的两个 Key 文件的地址，这里只需填写对应的文件名即可。</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>以上完成之后，在命令行中输入 <code>ssh -T git@xxx.com</code> （xxx 就写刚才在配置文件中 Host 后面的名字）与远程进行验证，验证成功就会显示如下信息。</p>
<pre><code class="shell">$ ssh -T git@github.com
Hi SmartJunNi! You&#39;ve successfully authenticated, but GitHub does not provide shell access.

$ ssh -T git@other.github.com
ssh git@github.com
Hi junoni! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
</code></pre>
<h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><p>如果在项目中使用 <code>git push</code> 时提示<code>[remote reject]   (Permission denied)</code> 。如下所示</p>
<pre><code class="shell">Counting objects: 3, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 252 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To other.github.com:junoni/nimon.git
 ! [remote rejected] master -&gt; master (permission denied)
error: failed to push some refs to &#39;git@other.github.com:junoni/nimon.git&#39;
</code></pre>
<p>我花了一个半小时从 google 到 stackoverflow 查了个边，就差没有百度一下了，就是没有找到可以解决的办法。这时我发现最后一行的<code>git@other.github.com:junoni/nimon.git</code> 这个地址，我想了想，刚刚配置了 config 这个文件，其中<code>Host</code>   使用的是 <code>other.github.com</code>，我用 <code>git remote -v</code> 查看了当前远程仓库的 origin 。</p>
<pre><code class="shell">$ git remote -v
origin    git@github.com:junoni/nimon.git (fetch)
origin    git@github.com:junoni/nimon.git (push)
</code></pre>
<p>可以看到，fetch 和 push 的 origin 地址都是 git@github.com ，而不是 git@other.github.com ，我就抱着试试的心态，改成了 git@other.github.com。还有一个步骤，将 <code>other</code> 加入到密钥列表中。</p>
<pre><code class="shell">$ ssh-add ~/.ssh/other
</code></pre>
<p> 再尝试 push 一下，没想到成功了。如迈克尔•乔丹所说：“我可以接受失败，但我不能接受放弃。”</p>
<p>当然，添加之后我们还可以查看当前密钥列表。也可以删除密钥。</p>
<pre><code class="shell">$ ssh-add -l
$ ssh-add -d ~/.ssh/other
</code></pre>
<p>类似debug，查看与远程连接情况。</p>
<pre><code class="Shell">$ ssh -v git@github.com
</code></pre>
<p>总结：我们设置的远程仓库的地址必须和 config 文件中设置的域名映射地址相同，不然就会出现错误。</p>
<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><h2 id="查看全局config信息"><a href="#查看全局config信息" class="headerlink" title="查看全局config信息"></a>查看全局config信息</h2><p>mac 下在~/.gitconfig 文件中配置 git 的全局信息。使用 <code>git config --list</code> 可以列出全局配置信息。</p>
<pre><code class="shell">$ git config --list
</code></pre>
<p><strong>用户信息</strong><br>配置你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p>
<pre><code>$ git config --global user.name “youname”
$ git config --global user.email “12345@example.com”
</code></pre><p>如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p>
<h2 id="GIT总结"><a href="#GIT总结" class="headerlink" title="GIT总结"></a>GIT总结</h2><p><strong>查看配置信息</strong><br>查看已有的配置信息</p>
<pre><code>$ git config --list
$ git config -l
</code></pre><p><strong>获取帮助</strong><br>例如想获取config命令的帮助信息</p>
<pre><code>$ git help config 
$ git config --help
</code></pre><p><strong>初始化新仓库</strong></p>
<pre><code>$ git init
</code></pre><p>初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。</p>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：<br><strong>跟踪文件：</strong>（将文件加到暂存区域）</p>
<pre><code>$ git add readme.txt
</code></pre><p><strong>跟踪全部文件</strong></p>
<pre><code>$ git add .
</code></pre><p><strong>提交更新</strong></p>
<pre><code>$ git commit -m “first version”
</code></pre><p><strong>上传（推送）到github</strong></p>
<pre><code>$ git push origin master
</code></pre><p><strong>从现有仓库克隆</strong></p>
<pre><code>$ git clone git://github.com/youname/project.git
$ git clone git@github.com:youname/project.git
$ git clone https://github.com/youname/project.git
</code></pre><p><strong>检查当前文件状态</strong></p>
<pre><code>$ git status
</code></pre><p><strong>创建.gitignore文件</strong></p>
<pre><code>$ touch .gitignore
</code></pre><p><strong>查看修改之后没有暂存起来的内容</strong></p>
<pre><code>$ git diff
</code></pre><p><strong>移除文件</strong></p>
<pre><code>$ git rm readme.txt
</code></pre><p><strong>重命名文件</strong></p>
<pre><code>$ git mv oldname.txt newname.txt
</code></pre><p><strong>查看提交历史</strong></p>
<pre><code>$ git log
</code></pre><p><strong>取消暂存</strong></p>
<pre><code>$ git reset HEAD readme.txt
</code></pre><p><strong>添加远程仓库</strong>（远程仓库必须先在github上建好）</p>
<pre><code>$ git remote add [shortname] [url]
</code></pre><p><strong>实例：</strong></p>
<pre><code>$ git remote add origin git@github.com:youname/yourRepo.git
</code></pre><p><strong>推送数据到仓库</strong></p>
<pre><code>$ git push [remote-name] [branch-name]
</code></pre><p>如果要把本地的 master 分支推送到origin服务器上（再次说明下，克隆操作会自动使用默认的master 和origin 名字），可以运行下面的命令：</p>
<pre><code>$ git push origin master
</code></pre><p><strong>从远程仓库抓取数据</strong></p>
<pre><code>$ git fetch [remote-name]
</code></pre><p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库<br><strong>远程仓库的删除</strong></p>
<pre><code>$ git remote rm origin
</code></pre><p><strong>远程仓库重命名</strong>(此处命名的是上文添加远程仓库中的shortname)</p>
<pre><code>$ git remote rename origin origin2
</code></pre><p><strong>自动补全</strong><br>输入命令后按tab键，就会看到列出所有匹配的可用命令建议：</p>
<pre><code>$ git co&lt;tab&gt;
</code></pre><h2 id="GIT分支"><a href="#GIT分支" class="headerlink" title="GIT分支"></a>GIT分支</h2><p><strong>创建一个名为“testing”的分支</strong></p>
<pre><code>$ git branch testing
</code></pre><p>切换到“testing”分支(默认为master分支)</p>
<pre><code>$ git checkout testing
</code></pre><p><strong>新建并切换到该分支</strong></p>
<pre><code>$ git checkout -b iss53
</code></pre><p>这条命令相当于执行下面这两条命令</p>
<pre><code>$ git branch iss53
$ git checkout iss53
</code></pre><p><strong>删除hotfix分支</strong>（如果该分支还未被合并则会提示错误，因为这样会丢失数据）</p>
<pre><code>$ git branch -d hotfix
</code></pre><p><strong>强制删除hotfix分支</strong>（强制删除，不会提示错误）</p>
<pre><code>$ git branch -D hotfix
</code></pre><p><strong>合并iss53分支</strong>（先切换到master分支）</p>
<pre><code>$ git checkout master
$ git merge iss53
</code></pre><p><strong>查看当前所有分支</strong></p>
<pre><code>$ git branch
</code></pre><p><strong>查看各个分支最后一个提交对象的信息</strong></p>
<pre><code>$ git branch -v
</code></pre><p><strong>查看已经与当前分支合并的分支</strong>（已经合并的查出来后可以删掉）</p>
<pre><code>$ git branch --merge
</code></pre><p><strong>查看未与当前分支合并的分支</strong></p>
<pre><code>$ git branch --no-merged
</code></pre><p><strong>同步远程服务器数据到本地</strong></p>
<pre><code>$ git fetch origin
</code></pre><p><strong>从新添加的远程仓库下载数据</strong></p>
<pre><code>$ git remote add teamone git://git.team1.ourcompany.com
$ git fetch teamone
</code></pre><p><strong>分化一个新的分支</strong>(使用这个命令会从服务器上下载master最新的版本，所以如果当前本地版本不是最新的，新的分支和本地分支会不同)</p>
<pre><code>$ git checkout -b test1 origin/master
</code></pre><p>假如你用这个新的分支进行git push，并且通过了合并，那么会在远程仓库建立一个新的同名分支<br>删除该分支的方法</p>
<pre><code>$ git push origin :test1
</code></pre><p><strong>分支的衍合：</strong>将test1分支衍合到master主分支</p>
<pre><code>$ git checkout test1
$ git rebase master
</code></pre><p>另一种方法，直接衍合，不用再先切换到test1</p>
<pre><code>$ git rebase master test1
</code></pre><p><strong>快进master分支</strong></p>
<pre><code>$ git checkout master
$ git merge client
</code></pre><h1 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h1><ul>
<li>查看远程库信息，使用<code>git remote -v</code>；</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>
<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>
</ul>
<p><strong>找到历史提交的commit ID</strong></p>
<pre><code>git log  --graph --pretty=oneline --abbrev-commit
</code></pre><h1 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h1><p> <strong>小结</strong></p>
<ul>
<li>命令<code>git tag &lt;name&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li>
<li><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li>
<li><code>git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以用PGP签名标签；</li>
<li>命令<code>git tag</code>可以查看所有标签。</li>
<li><code>git show &lt;tagname&gt;</code>可以查看标签的详情</li>
</ul>
<h1 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h1><p><strong>小结</strong></p>
<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签</li>
</ul>
<pre><code class="shell">git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;
</code></pre>
<p>touch readme.md</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>刚开始，你需要选择一个目录，开始一个新的 repository。使用以下命令可以在当前目录下初始化 Git 。</p>
<p><strong>git init </strong></p>
<p>git status  查看仓库的状态</p>
<p>git add 向暂存区中添加文件</p>
<p>git commit 保存仓库的历史记录</p>
<p>记录一行提交信息</p>
<pre><code class="shell">$ git commit -m &quot;First Commit&quot;
</code></pre>
<h2 id="记录详细提交信息"><a href="#记录详细提交信息" class="headerlink" title="记录详细提交信息"></a>记录详细提交信息</h2><p>请不要加-m，直接执行 git commit 命令。</p>
<pre><code class="shell">$ git commit 
+git tracks changes of files.

# Please enter the commit message for your changes. Lines starting
# with &#39;#&#39; will be ignored, and an empty message aborts the commit.
# On branch dev
# Your branch is ahead of &#39;origin/dev&#39; by 3 commits.
#   (use &quot;git push&quot; to publish your local commits)
#
# Changes to be committed:
#       modified:   readme.md
#
</code></pre>
<p>在编辑器中记录提交信息</p>
<ul>
<li>第一行：用一行文件简述提交的更改内容</li>
<li>第二行：空行</li>
<li>第三行：记录更改的原因和详细内容</li>
</ul>
<p>在以 # 标位注释的 Changes to be committed 可以查看本次提交中包含的文件。其他信息不必修改。</p>
<h2 id="终止提交"><a href="#终止提交" class="headerlink" title="终止提交"></a>终止提交</h2><p>请将提交信息留空并直接关闭编译器，随后提交就会被中止。</p>
<pre><code class="shell">Aborting commit due to empty commit message.
</code></pre>
<p>##查看提交后的状态</p>
<p>执行完git commit 命令后再来查看当前状态</p>
<pre><code class="shell">$ git status
On branch dev
nothing to commit, working tree clean
</code></pre>
<p>当前工作树处于刚刚提交的最新状态，所以结果显示没有更改。</p>
<h2 id="git-log-查看提交日志"><a href="#git-log-查看提交日志" class="headerlink" title="git log 查看提交日志"></a>git log 查看提交日志</h2><p>可以查看以往仓库中提交的日志。包括什么人在什么时候进行了提交或合并，以及操作后有怎样的差别。</p>
<pre><code class="shell">$ git log
commit d97ade219a7f50f61790a14aa40f3142a07f49ba
Author: SimpleLifee &lt;824291045@qq.com&gt;
Date:   Sat May 20 16:47:09 2017 +0800

    First Commit
</code></pre>
<p>Commit 旁边显示的是这个提交的哈希值。这个值很重要，在后面会讲到。</p>
<p>Author 栏中显示的是我们给 Git 设置的用户名和邮箱。</p>
<p>Date 栏显示的是提交的日期和时间。</p>
<p>最后是提交信息。</p>
<h2 id="只显示提交信息的第一行"><a href="#只显示提交信息的第一行" class="headerlink" title="只显示提交信息的第一行"></a>只显示提交信息的第一行</h2><p>在 <code>git log</code>  后面加上 <code>--pretty=short</code></p>
<pre><code class="shell">$ git log --pretty=short

commit d97ade219a7f50f61790a14aa40f3142a07f49ba
Author: SimpleLifee &lt;824291045@qq.com&gt;

    First Commit
</code></pre>
<h2 id="只显示指定目录、文件的日志"><a href="#只显示指定目录、文件的日志" class="headerlink" title="只显示指定目录、文件的日志"></a>只显示指定目录、文件的日志</h2><p>在 <code>git log</code> 后加上文件名或者目录名即可。</p>
<h2 id="显示改动的文件"><a href="#显示改动的文件" class="headerlink" title="显示改动的文件"></a>显示改动的文件</h2><p>如果想查看提交所带来的改动，可以加上 <code>-p</code> 参数，文件的前后差别就会显示在提交信息之后。</p>
<pre><code class="Shell">$ git log -p
</code></pre>
<p>只查看某个文件提交前和提交后的差别</p>
<pre><code class="shell">$ git log -p README.md
</code></pre>
<p>如上， 我们不必依次记下全部参数，每当有想查看的日志就积极去查，慢慢就能得心应手了。</p>
<h2 id="简要列出每个commit的内容变化"><a href="#简要列出每个commit的内容变化" class="headerlink" title="简要列出每个commit的内容变化"></a>简要列出每个commit的内容变化</h2><pre><code class="shell">$ git log --stat
</code></pre>
<p>##git diff 查看更改前后的差别</p>
<p><code>git diff</code> 可以查看工作树、暂存区、最新提交之间的差别。</p>
<p>注意暂存区是指 <code>git add</code> 之后，但未 <code>git commit</code>  时保存在暂存区的内容。这个时候可以使用 <code>git diff</code> 来查看工作树和暂存区的差别。</p>
<pre><code class="shell">$ git diff readme.md
diff --git a/readme.md b/readme.md
index 7f612d5..c4123d2 100644
--- a/readme.md
+++ b/readme.md
@@ -11,5 +11,5 @@ dev: other
 something happend.
 i will be fine.
 hah
-
+hey! Git!
</code></pre>
<p>注意，这里的 <code>+</code>  标出的是新添加的行，被删除的行则用 <code>-</code> 标出。</p>
<p>这时候如果使用 <code>git add</code> 将 <code>README.md</code> 加入暂存区后。工作树和正常启动内容并无差别，结果什么都不会显示。</p>
<pre><code class="shell">$ git add README.md
</code></pre>
<h2 id="查看工作树和最新提交的差别"><a href="#查看工作树和最新提交的差别" class="headerlink" title="查看工作树和最新提交的差别"></a>查看工作树和最新提交的差别</h2><p> 当使用<code>git add</code> 将 <code>README.md</code> 加入暂存区后，要查看工作树与最新提交的差别，请使用以下命令。</p>
<pre><code class="shell">$ git diff HEAD
diff --git a/readme.md b/readme.md
index 7f612d5..c4123d2 100644
--- a/readme.md
+++ b/readme.md
@@ -11,5 +11,5 @@ dev: other
 something happend.
 i will be fine.
 hah
-
+hey! Git!
</code></pre>
<p>不妨养成这样一个好习惯，在执行 <code>git commit</code> 命令之前先执行 <code>git diff HEAD</code> 查看本次提交与上次提交之间有什么差别，等确认完毕再进行提交。这里的 <code>HEAD</code> 指当前分支中最新的一次提交的指针。</p>
<h1 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h1><h2 id="git-branch-显示分支一览表"><a href="#git-branch-显示分支一览表" class="headerlink" title="git branch 显示分支一览表"></a>git branch 显示分支一览表</h2><p>这个命令会将本地的分支名列表显示，* 表示当前所在分支。</p>
<pre><code class="shell">$ git branch
* master
</code></pre>
<h2 id="git-checkout-b-创建、切换分支"><a href="#git-checkout-b-创建、切换分支" class="headerlink" title="git checkout -b 创建、切换分支"></a>git checkout -b 创建、切换分支</h2><p>以当前分支为基础创建新的分支，可以使用 <code>git checkout -b</code>命令</p>
<h2 id="切换到-feature-A-分支并进行提交"><a href="#切换到-feature-A-分支并进行提交" class="headerlink" title="切换到 feature-A 分支并进行提交"></a>切换到 feature-A 分支并进行提交</h2><p>执行下面的命令，创建名为 <code>feature-A</code></p>
<pre><code class="shell">$ git checkout -b feature-A
Switched to a new branch &#39;feature-A&#39;
</code></pre>
<p>实际上，以上语句等同于</p>
<pre><code class="shell">$ git branch feature-A
$ git checkout feature-A
</code></pre>
<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><pre><code class="shell">$ git checkout master
</code></pre>
<p>##切换回上一个分支</p>
<pre><code class="Shell">$ git checkout -
</code></pre>
<p>使用 <code>-</code> （连字符） 代替分支名。</p>
<h2 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h2><p>顾名思义，特性分支是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常开发中，往往会创建数个特性分支，同时再保留一个随时可以发布软件的稳定分支。稳定分支一般由 <code>master</code>  分支担当。</p>
<p>只要保持这样一个开发流程，就能保证master分支可以随时供人查看。其他开发者也可以放心大胆从master分支创建新的特性分支。</p>
<p>##主干分支</p>
<p>特性分支的原点，也是合并的终点。主干分支没有开发到一半的代码，可以随时供人查看。</p>
<p>主干分支可以有多个，使用 Tag 标签创建版本信息。</p>
<h2 id="git-merge-合并分支"><a href="#git-merge-合并分支" class="headerlink" title="git merge 合并分支"></a>git merge 合并分支</h2><p>先切换到master，然后与 <code>feature-A</code> 合并</p>
<pre><code class="shell">$ git merge --no-ff feature-A
</code></pre>
<h2 id="以图表形式查看分支"><a href="#以图表形式查看分支" class="headerlink" title="以图表形式查看分支"></a>以图表形式查看分支</h2><p>可以直观地用图表形式输出提交的日志。</p>
<pre><code class="shell">$ git log --graph
*   commit 685c45a39c33a4777d14fb29f6f0bfb9b9920c49
|\  Merge: 6b15d42 40befaa
| | Author: SimpleLifee &lt;824291045@qq.com&gt;
| | Date:   Sat May 20 18:04:48 2017 +0800
| |
| |     merge
| |
| *   commit 40befaab3f0db6fd47e2d553b88428a4ca39e670
| |\  Merge: a0b10f9 6b15d42
| |/  Author: SimpleLifee &lt;824291045@qq.com&gt;
|/|   Date:   Sat May 20 17:51:52 2017 +0800
| |
| |       fix
| |
</code></pre>
<h1 id="更改提交的操作"><a href="#更改提交的操作" class="headerlink" title="更改提交的操作"></a>更改提交的操作</h1><h2 id="git-reset-回溯历史版本"><a href="#git-reset-回溯历史版本" class="headerlink" title="git reset 回溯历史版本"></a>git reset 回溯历史版本</h2><p><strong>回溯到创建 <code>feature-A</code> 分支前</strong></p>
<p>让仓库的HEAD、暂存区、当前的工作树回溯到指定状态。</p>
<pre><code class="shell">$ git reset --hard &lt;哈希值&gt;
</code></pre>
<p> <strong>创建 fix-B 分支</strong></p>
<p> <strong>推进至feature-A分支合并后的状态</strong></p>
<p>首先回复到feature-A分支合并后的状态，可以称之为“推进历史”。</p>
<p><code>git log</code> 只能查看以当前状态为终点的历史日志。</p>
<p>所以这里要使用<code>git reflog</code> 查看当前仓库的操作历史， 可以看到commit、checkout、reset、merge等Git命令的执行记录。</p>
<h2 id="消除冲突"><a href="#消除冲突" class="headerlink" title="消除冲突"></a>消除冲突</h2><p>如果系统提示我们文件发生了冲突，那么不解决冲突就无法完成合并，所以需要我们手动来解决冲突。解决完冲突文件后再执行<code>git add</code> 和<code>git commit</code> 。</p>
<h2 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h2><pre><code>git commit --amend
</code></pre><h2 id="git-rebase-i-压缩历史"><a href="#git-rebase-i-压缩历史" class="headerlink" title="git rebase -i 压缩历史"></a>git rebase -i 压缩历史</h2><p>在合并特性分支之前，如果发现已提交的内容中有些拼写错误，不妨提交一个修改，然后<strong>将这个修改包含到前一个提交之中</strong>，压缩成一个历史记录。这是个会经常用到的技巧。</p>
<h3 id="创建-feature-C-分支"><a href="#创建-feature-C-分支" class="headerlink" title="创建 feature-C 分支"></a>创建 feature-C 分支</h3><p>首先创建 feature-C 分支，然后 add 和 commit命令。</p>
<p>但是没必要每次这么麻烦。</p>
<pre><code class="Shell">$ git commit -am &quot;Add feature-C&quot;
</code></pre>
<blockquote>
<p>执行上面语句的前提是，当前工作树中没有新增的Untracked  的文件。</p>
</blockquote>
<h3 id="修正拼写错误"><a href="#修正拼写错误" class="headerlink" title="修正拼写错误"></a>修正拼写错误</h3><p>修改错误之后，使用<code>git diff</code> 来查看差别。</p>
<pre><code class="Shell">$ git diff
diff --git a/readme.md b/readme.md
index 10f9ebb..3bbe2d0 100644
--- a/readme.md
+++ b/readme.md
@@ -1,2 +1,3 @@
 C
 C
+fix C
</code></pre>
<p>然后进行提交</p>
<pre><code class="Shell">$ git commit -am &quot;Fix Typo&quot;
[C c3955c1] Fix Typo
 1 file changed, 1 insertion(+)
</code></pre>
<p>错字漏字等失误称作typo，但是我们不希望在历史记录中看到这类提交，因为健全的历史记录不需要它们。</p>
<h3 id="更改历史"><a href="#更改历史" class="headerlink" title="更改历史"></a>更改历史</h3><p>我们将修正的内容与之前的一次提交合并，在历史记录中合并为一次完美的提交。</p>
<pre><code class="Shell">$ git rebase -i HEAD~2
</code></pre>
<p>上面的命令，可以选定当前分支中包含HEAD ( 最新提交 ) 在内的两个最新历史记录为对象，并在编辑器中打开。</p>
<pre><code class="shell">pick 695471a Add C
pick 2f8a965 fix typo

# Rebase 1db92da..2f8a965 onto 1db92da (2 commands)
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like &quot;squash&quot;, but discard this commit&#39;s log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
</code></pre>
<p>695471a我们将 <code>2f8a965</code> 的 <code>fix typo</code> 的历史记录压缩到 <code>695471a</code> 的 <code>Add C</code>里。按照下图所示，将<code>2f8a965</code>左侧的 <code>pick</code> 部分删除，改写为 <code>fixup</code> 。</p>
<pre><code class="Shell">pick 695471a Add C
fixup 2f8a965 fix typo
</code></pre>
<p>保存编译器里的内容，关闭编辑器</p>
<pre><code class="Shell">[detached HEAD 5f770a9] nnnnnnnn
 Date: Sat May 20 22:07:28 2017 +0800
 1 file changed, 1 insertion(+)
Successfully rebased and updated refs/heads/C.
</code></pre>
<p>系统显示 rebase 成功，也就是以下面这两个提交作为对象，将 <code>fix typo</code> 的内容合并到了上一个提交<code>Add C</code> 之中，改写成一个新的提交。</p>
<ul>
<li>695471a Add C</li>
<li>2f8a965 fix typo</li>
</ul>
<p>现在查看提交日志时会发现 <code>Add C</code> 的哈希值以及不再是 <code>695471a</code> ，这证明提交已经被更改了。</p>
<pre><code class="shell">$ git log --graph --oneline
* 5f770a9 Add C
* 1db92da haha
* c1aabf4 Add B
...
</code></pre>
<p>这样，<code>fix typo</code>就从历史中被抹去了，也相当于 <code>Add C</code>从来没有出现过拼写错误。这算是一种良性的历史改写。</p>
<h3 id="合并至master分支"><a href="#合并至master分支" class="headerlink" title="合并至master分支"></a>合并至master分支</h3><p>C 分支的使命告一段落，我们将它与master分支合并。</p>
<pre><code class="Shell">$ git checkout master
Switched to branch &#39;master&#39;

$ git merge --no-ff feature-C
Merge made by the &#39;recursive&#39; strategy.
 a         | 2 ++
 readme.md | 2 ++
 2 files changed, 4 insertions(+)
 create mode 100644 a
 create mode 100644 readme.md
</code></pre>
<p>按照递归策略合并。</p>
<h1 id="推送至远程仓库"><a href="#推送至远程仓库" class="headerlink" title="推送至远程仓库"></a>推送至远程仓库</h1><blockquote>
<p>建议在新建远程仓库的时候不要勾选自动生成README文件的选项。</p>
</blockquote>
<h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><p>我们用 <code>git remote add</code> 命令将它设置成本地仓库的远程仓库。</p>
<pre><code class="Shell">$ git remote add origin git@github.com:9981NAN/9981NAN.git
</code></pre>
<p>这样，Git会自动将 <code>git@github.com:9981NAN/9981NAN.git</code> 远程仓库名称设置为 origin （ 标识符 ）</p>
<h2 id="添加多个-URL-地址"><a href="#添加多个-URL-地址" class="headerlink" title="添加多个 URL 地址"></a>添加多个 URL 地址</h2><p>像上面 <code>git remote add origin &lt;url1&gt;</code> 添加第一个URL之后，如果想要添加多个 URL 地址，那么可以使用<code>git remote set-url --add origin &lt;url2&gt;</code> 添加第二个URL。 </p>
<pre><code class="shell">$ git remote set-url --add origin git@github.com:9981NAN/9981NAN.git
</code></pre>
<p>这样一来，以后每次 <code>git push origin master</code>  的时候，就会自动向多个远程仓库中推送了。 </p>
<blockquote>
<p>但是使用 git pull 时，只能拉取origin里的一个URL地址（即fetch-url，如上），这个 fetch-url 默认是你添加到origin 的第一个地址。</p>
<p>如果你想更改，只需要更改 config 文件里，那几个url的顺序即可。 fetch-url 会直接对应排行第一的那个url 链接。</p>
</blockquote>
<h2 id="推送至master分支"><a href="#推送至master分支" class="headerlink" title="推送至master分支"></a>推送至master分支</h2><p>如果想把当前分支下本地仓库的内容推送给远程仓库，需要用到 <code>git push</code>，假定我们在master分支下</p>
<pre><code class="Shell">$ git push -u origin master
</code></pre>
<p><code>-u</code>参数可以在推送的同时，将origin仓库的master分支设置为本地仓库当前分支的 upstream（上游）。这样一来，下次运行 <code>git pull</code>命令从远程仓库获取内容时，本地仓库这个分支就可以直接从origin 的master 分支获取内容，省去了另外添加参数的麻烦。</p>
<h2 id="推送至master以外的分支"><a href="#推送至master以外的分支" class="headerlink" title="推送至master以外的分支"></a>推送至master以外的分支</h2><p>创建其他分支</p>
<pre><code class="Shell">$ git checkout -b feature-D
</code></pre>
<p>将它push给远程仓库，并保持分支名不变</p>
<pre><code class="shell">$ git push -u origin feature-D
</code></pre>
<h1 id="从远程仓库获取"><a href="#从远程仓库获取" class="headerlink" title="从远程仓库获取"></a>从远程仓库获取</h1><p>假设现在有另一名开发者要来共同开发，在另一个目录下新建本地仓库。</p>
<h2 id="git-clone-获取远程仓库"><a href="#git-clone-获取远程仓库" class="headerlink" title="git clone 获取远程仓库"></a>git clone 获取远程仓库</h2><pre><code class="shell">$ git clone git@github.com:9981NAN/9981NAN.git
</code></pre>
<blockquote>
<p>注意clone的目录不要与之前操作的仓库在同一目录下</p>
</blockquote>
<p>执行 <code>git clone</code>命令后我们会默认处于master分支下，同时系统会自动将origin设置成该远程仓库的标识符。</p>
<p>我们可以使用下面的命令查看本地仓库和远程仓库的分支信息。</p>
<pre><code class="shell">$ git branch -a
</code></pre>
<h2 id="获取远程的feature-D分支"><a href="#获取远程的feature-D分支" class="headerlink" title="获取远程的feature-D分支"></a>获取远程的feature-D分支</h2><p>我们试着将feature-D分支获取至本地仓库。</p>
<pre><code class="shell">$ git checkout -b feature-D origin/feature-D
</code></pre>
<p><code>-b</code> 参数后面是本地仓库中新建分支的名称，可以与远程仓库不同名，但是建议同名，便于理解。</p>
<h2 id="向本地的feature-D分支提交更改"><a href="#向本地的feature-D分支提交更改" class="headerlink" title="向本地的feature-D分支提交更改"></a>向本地的feature-D分支提交更改</h2><p>假定我们是另一位开发者，要做一个新的提交。在修改文件内容后进行查看和提交。</p>
<pre><code class="shell">$ git diff

$ git commit -am &quot;Add feature-D&quot;
</code></pre>
<h2 id="推送至feature-D分支"><a href="#推送至feature-D分支" class="headerlink" title="推送至feature-D分支"></a>推送至feature-D分支</h2><p>在<code>feature-D</code>分支下直接使用 <code>git push</code> 即可</p>
<pre><code class="shell">$ git diff
</code></pre>
<h2 id="git-pull-获取最新的远程仓库分支"><a href="#git-pull-获取最新的远程仓库分支" class="headerlink" title="git pull 获取最新的远程仓库分支"></a>git pull 获取最新的远程仓库分支</h2><p>回到我们刚刚放下操作的目录，这边的本地仓库中只是创建了feature-D分支，并没有在feature-D进行任何提交，而远程仓库已经有了我们刚刚推送的提交。这时候就可以用<code>git pull</code> ，将本地的 feature-D 分支更新到最新状态。</p>
<pre><code class="shell">$ git pull origin feature-D
</code></pre>
<blockquote>
<p>如果两人同时修改了同一部分的源代码，push时就很容易发生冲突。所以多名开发者在同一个分支中进行作业时，为了减少冲突的情况，建议更频繁地进行push和pull操作。</p>
</blockquote>
<h1 id="GitHub功能"><a href="#GitHub功能" class="headerlink" title="GitHub功能"></a>GitHub功能</h1><h2 id="通过部分名称搜索文件"><a href="#通过部分名称搜索文件" class="headerlink" title="通过部分名称搜索文件"></a>通过部分名称搜索文件</h2><p>在仓库页面按下键盘T 键，然后输入要找的文件或者目录。速度非常快。</p>
<h2 id="查看差别"><a href="#查看差别" class="headerlink" title="查看差别"></a>查看差别</h2><h3 id="查看分支间的差别"><a href="#查看分支间的差别" class="headerlink" title="查看分支间的差别"></a>查看分支间的差别</h3><p>以我的9981NAN项目为例，要比较nimon分支和yong分支的差别，可以直接在浏览器URL中输入：</p>
<pre><code>https://github.com/9981NAN/9981NAN/compare/nimon...yong
</code></pre><p>这样就可以查看两个分支间的差别了。</p>
<h3 id="查看与几天前的差别"><a href="#查看与几天前的差别" class="headerlink" title="查看与几天前的差别"></a>查看与几天前的差别</h3><p>输入下面的URL就可以查看nimon分支最近7天内的差别了。</p>
<pre><code>https://github.com/9981NAN/9981NAN/compare/nimon@{7.day.ago}...nimon
</code></pre><p>类似的还有</p>
<ul>
<li>day</li>
<li>week</li>
<li>month</li>
<li>year</li>
<li>hour</li>
</ul>
<h3 id="查看指定日期之间的差别"><a href="#查看指定日期之间的差别" class="headerlink" title="查看指定日期之间的差别"></a>查看指定日期之间的差别</h3><pre><code>https://github.com/9981NAN/9981NAN/compare/nimon@{2017-05-19}...nimon
</code></pre><h2 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h2><h3 id="通过提交信息操作Issue"><a href="#通过提交信息操作Issue" class="headerlink" title="通过提交信息操作Issue"></a>通过提交信息操作Issue</h3><p>在项目的Issue一览表中，每一个Issue标题的下面部分都分配 “#18” 的编号。我们只要在描述信息中加入 “#18” ，就可以在Issue中显示该提交的相关信息，使关联的提交一目了然。</p>
<h3 id="Close-Issue"><a href="#Close-Issue" class="headerlink" title="Close Issue"></a>Close Issue</h3><p>如果一个处于 Open 状态的 Issue 已经处理完毕，只要在该提交中以下列任意一种格式描述提交信息，对应的 Issue 就会被 close 。</p>
<ul>
<li>fix #18</li>
<li>fixes #18</li>
<li>fixed #18</li>
<li>close #18</li>
<li>closes #18</li>
<li>closed #18</li>
<li>resolve #18</li>
<li>resolves #18</li>
<li>resloved #18</li>
</ul>
<p>这样我们每次提交并push之后，就不必每次都到 Issue 中寻找相应的 Issue 再手动关闭了。这是一项很实用的功能。</p>
<blockquote>
<p>Issue 和 Pull Request 的编号通用。</p>
</blockquote>
<h2 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h2><h5 id="conversation"><a href="#conversation" class="headerlink" title="conversation"></a>conversation</h5><blockquote>
<p>引用评论，选中别人的评论后按 R 键。</p>
<p>在评论中应用表情，输入 “ ：” 即可选择。</p>
</blockquote>
<h3 id="Files-Changed"><a href="#Files-Changed" class="headerlink" title="Files Changed"></a>Files Changed</h3><p>默认情况下，系统会将空格的不同也高亮显示，想要关闭之？ 在URL 的末尾添加 “ ?w=1 ” 就可以不显示空格的差异了。</p>
<p>将鼠标放到被更改行号的左侧，可以看到一个加号，我们可以点击这个加号在代码中插入评论。这样评论是针对哪行代码就一目了然了</p>
<h2 id="Pulse"><a href="#Pulse" class="headerlink" title="Pulse"></a>Pulse</h2><p>Pulse是体现该仓库软件开发活跃度的功能，近期仓库创建了多个pull request 或 Issue，有多少人参与了这个仓库的开发。用户可以判断目前这个人间是否正在积极开发，在挑选GitHub上开发的软件时，可以作为一个重要的衡量标准。</p>
<h1 id="发送Pull-Request"><a href="#发送Pull-Request" class="headerlink" title="发送Pull Request"></a>发送Pull Request</h1><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><p>前面两步完成之后，我们需要在特性分支中进行开发</p>
<h4 id="确认分支"><a href="#确认分支" class="headerlink" title="确认分支"></a>确认分支</h4><pre><code class="shell">$ git br -a
* master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/master
</code></pre>
<h4 id="创建特性分支"><a href="#创建特性分支" class="headerlink" title="创建特性分支"></a>创建特性分支</h4><p>在 <code>work</code> 之后加上 <code>master</code> 表明在 <code>master</code> 分支的基础上创建 <code>work</code> 分支。</p>
<pre><code class="shell">$ git checkout -b work master
Switched to a new branch &#39;work&#39;
</code></pre>
<h3 id="添加代码"><a href="#添加代码" class="headerlink" title="添加代码"></a>添加代码</h3><p>在 <code>readme.md</code> 文件中添加要增加的代码。</p>
<h3 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h3><pre><code class="shell">$ git commit -am &quot;Add pull request&quot;
[work f3d798e] Add pull request
 1 file changed, 1 insertion(+), 2 deletions(-)
</code></pre>
<h3 id="创建远程分支"><a href="#创建远程分支" class="headerlink" title="创建远程分支"></a>创建远程分支</h3><p>把在本地创建的分支推送到远程仓库，如果远程仓库没有该分支，那么就创建之。</p>
<pre><code class="shell">$ git push origin work
Counting objects: 3, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 283 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:junoni/nimon.git
 * [new branch]      work -&gt; work
</code></pre>
<h3 id="在GitHub页面上创建Pull-Request"><a href="#在GitHub页面上创建Pull-Request" class="headerlink" title="在GitHub页面上创建Pull Request"></a>在GitHub页面上创建Pull Request</h3><h3 id="不进行Fork直接从分支发送Pull-Request"><a href="#不进行Fork直接从分支发送Pull-Request" class="headerlink" title="不进行Fork直接从分支发送Pull Request"></a>不进行Fork直接从分支发送Pull Request</h3><p>前提是拥有这个仓库编辑的权限</p>
<h2 id="仓库的维护"><a href="#仓库的维护" class="headerlink" title="仓库的维护"></a>仓库的维护</h2><p>Fork 或者 clone 来的仓库，一旦放置不管就会离最新的源代码越来越远。这时候我们需要让本地仓库与源代码保持最新状态。</p>
<p>我们需要将原仓库设置为远程仓库，从该仓库获取<code>fetch</code> 数据与本地仓库进行合并 <code>merge</code>  。</p>
<h3 id="Fork-与-clone"><a href="#Fork-与-clone" class="headerlink" title="Fork 与 clone"></a>Fork 与 clone</h3><h3 id="给原仓库设置名称"><a href="#给原仓库设置名称" class="headerlink" title="给原仓库设置名称"></a>给原仓库设置名称</h3><pre><code class="shell">$ git remote add upstream git@github.com:SimpleLifee/nimon.git
</code></pre>
<p>这样，我们这个仓库将以upstream作为原仓库的标识符。这个环境下只需要设定一次。</p>
<p>可以下面的命令查看</p>
<pre><code class="shell">$ git remote -v
origin    git@github.com:junoni/nimon.git (fetch)
origin    git@github.com:junoni/nimon.git (push)
upstream    git@github.com:SimpleLifee/nimon.git (fetch)
upstream    git@github.com:SimpleLifee/nimon.git (push)
</code></pre>
<h3 id="获取最新数据"><a href="#获取最新数据" class="headerlink" title="获取最新数据"></a>获取最新数据</h3><p>要让仓库维持最新状态，只需要重复这一工作即可。</p>
<pre><code class="shell">$ git fetch upstream
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (7/7), done.
remote: Total 14 (delta 3), reused 14 (delta 3), pack-reused 0
Unpacking objects: 100% (14/14), done.
From github.com:SimpleLifee/nimon
 * [new branch]      dev        -&gt; upstream/dev
 * [new branch]      feature-A  -&gt; upstream/feature-A
 * [new branch]      master     -&gt; upstream/master
</code></pre>
<h1 id="接受-Pull-Request"><a href="#接受-Pull-Request" class="headerlink" title="接受  Pull Request"></a>接受  Pull Request</h1><h2 id="采纳-Pull-Request-之前的准备"><a href="#采纳-Pull-Request-之前的准备" class="headerlink" title="采纳 Pull Request 之前的准备"></a>采纳 Pull Request 之前的准备</h2><h3 id="将接受方的本地仓库更新至最新状态"><a href="#将接受方的本地仓库更新至最新状态" class="headerlink" title="将接受方的本地仓库更新至最新状态"></a>将接受方的本地仓库更新至最新状态</h3><h3 id="获取发送方的远程仓库"><a href="#获取发送方的远程仓库" class="headerlink" title="获取发送方的远程仓库"></a>获取发送方的远程仓库</h3><pre><code class="shell">$ git remote add PR发送者 git@github.com:junoni/nimon.git
</code></pre>
<p>查看添加后的情况</p>
<pre><code class="Shell">$ git remote -v
PR发送者    git@github.com:junoni/nimon.git (fetch)
PR发送者    git@github.com:junoni/nimon.git (push)
origin    git@github.com:SimpleLifee/nimon.git (fetch)
origin    git@github.com:SimpleLifee/nimon.git (push)
</code></pre>
<p>接着进行fetch</p>
<pre><code class="shell">$ git fetch PR发送者
remote: Counting objects: 32, done.
remote: Compressing objects: 100% (18/18), done.
remote: Total 32 (delta 14), reused 26 (delta 8), pack-reused 0
Unpacking objects: 100% (32/32), done.
From github.com:junoni/nimon
 * [new branch]      dev        -&gt; PR发送者/dev
 * [new branch]      master     -&gt; PR发送者/master
 * [new branch]      work       -&gt; PR发送者/work
</code></pre>
<p>现在我们获取了Pull Request 发送仓库以及分支的数据（PR发送者/work）</p>
<h3 id="创建用于检查的分支"><a href="#创建用于检查的分支" class="headerlink" title="创建用于检查的分支"></a>创建用于检查的分支</h3><p>前面我们只获取了远程仓库的数据，这些数据尚未反映在任何一个分支中。因此我们需要创建一个分支，用于模拟采纳 Pull Request 后的状态。由于这是我们第一个 Pull Request ，分支名就叫 <code>pr1</code> 。</p>
<pre><code class="shell">$ git checkout -b pr1
Switched to a new branch &#39;pr1&#39;
</code></pre>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>下面要将已经 fetch 完毕的 “PR发送者/work ” 的修改内容与 <code>pr1</code> 分支进行合并</p>
<pre><code class="shell">$ git merge PR发送者/work
</code></pre>
<p>这时候我们需要检查一下合并的情况。</p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>检查结束后<code>pr1</code> 分支就没用了，可以直接删除。我们需要先切换到 <code>pr1</code> 之外，例如 <code>master</code></p>
<pre><code class="shell">$ git checkout master
Previous HEAD position was f3d798e... Add pull request
Switched to branch &#39;master&#39;
Your branch is ahead of &#39;origin/master&#39; by 12 commits.
  (use &quot;git push&quot; to publish your local commits)
</code></pre>
<p>这时候，Git 提醒我们当前 <code>master</code> 分支已经比远程仓库多出 12 个新提交了，并建议我们使用 <code>git push</code> 向远程仓库推送新的提交。 </p>
<p>之后我们进行删除分支。</p>
<pre><code class="Shell">$ git branch -D pr1
Deleted branch pr1 (was 685c45a).
</code></pre>
<h2 id="采纳-Pull-Request"><a href="#采纳-Pull-Request" class="headerlink" title="采纳 Pull Request"></a>采纳 Pull Request</h2><p>我们可以打开浏览器找到相应的 Pull Request 页面，点击 merge pull request按钮，随后Pull Request的内容就会自动合并至仓库。</p>
<p>不过我们已经在本地构筑了相同的环境，只要通过 CLI 进行合并操作后再 push 至 Github，就可以完成Pull Request。</p>
<h3 id="合并到主分支"><a href="#合并到主分支" class="headerlink" title="合并到主分支"></a>合并到主分支</h3><p>首先我们切换到 <code>master</code> 分支上</p>
<pre><code class="Shell">$ git checkout master
</code></pre>
<p>然后合并 <code>PR发送者/work</code></p>
<pre><code class="Shell">$ git merge PR发送者/work
</code></pre>
<h3 id="Push-修改内容"><a href="#Push-修改内容" class="headerlink" title="Push 修改内容"></a>Push 修改内容</h3><p>先查看本地仓库和远程 GitHub端仓库库代码的差别</p>
<pre><code class="Shell">$ git diff origin/master
</code></pre>
<p>确认没有目的之外的差别后，进行push</p>
<pre><code class="shell">$ git push
Counting objects: 10, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (7/7), done.
Writing objects: 100% (10/10), 1.05 KiB | 0 bytes/s, done.
Total 10 (delta 3), reused 0 (delta 0)
remote: Resolving deltas: 100% (3/3), completed with 1 local object.
To github.com:SimpleLifee/nimon.git
   8caf54d..067a3c8  master -&gt; master
</code></pre>
<p>这样，仓库的 <code>Pull Request</code>会自动从 <code>Open</code> 状态变为 <code>Close</code> 状态。</p>
<p>至此，Pull Request 的操作都介绍完了。</p>
<h1 id="Hub命令"><a href="#Hub命令" class="headerlink" title="Hub命令"></a>Hub命令</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>如果使用Homebrew</p>
<pre><code class="Shell">$ brew install hub
</code></pre>
<p>然后，在shell的环境路径后面添加 <code>~/bin</code> 。</p>
<pre><code class="shell">$ echo &#39;export PATH=&quot;~/bin:$PATH&quot;&#39; &gt;&gt; ~/.bash_profile
</code></pre>
<p>重新启动shell，就可以使用hub命令了。</p>
<h4 id="确认运行情况"><a href="#确认运行情况" class="headerlink" title="确认运行情况"></a>确认运行情况</h4><pre><code class="Shell">$ hub --version
git version 2.11.0 (Apple Git-81)
hub version 2.2.9
</code></pre>
<h4 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h4><p>使用hub命令的最佳实践是将相应的 git 设置成 hub 的别名。hub 命令可以完成 git 命令的所有操作，只需要在 shell 的配置文件中（.bash_profile） 添加下面一句即可。</p>
<pre><code>eval &quot;$(hub alias -s)&quot;
</code></pre><h4 id="config-hub"><a href="#config-hub" class="headerlink" title="~/.config/hub"></a>~/.config/hub</h4><p>hub 命令在初次访问 GitHub 的 API 的时候会询问用户名和密码。</p>
<pre><code class="Shell">$ cat ~/.config/hub
github.com:
- user: SimpleLifee
  oauth_token: 5cb6fb57b65693dac153bf2c61dd642a916b268b
  protocol: https
</code></pre>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="hub-clone"><a href="#hub-clone" class="headerlink" title="hub clone"></a>hub clone</h4><p>使用 <code>hub clone</code> 命令，可以省去指定 <code>GitHub</code> 端仓库的部分</p>
<pre><code class="shell">$ hub clone nimon
</code></pre>
<p>上面这个命令与下面的命令效果相同。</p>
<pre><code class="shell">$ git clone git@github.com/SimpleLifee/nimon.git
</code></pre>
<p>如果要指定用户，可以输入以下命令。</p>
<pre><code class="Shell">$ hub clone junoni/nimon
</code></pre>
<p>上面这个命令与下面的命令效果相同。</p>
<pre><code>$ git clone git@github.com/junoni/nimon.git
</code></pre><h4 id="hub-remote-add"><a href="#hub-remote-add" class="headerlink" title="hub remote add"></a>hub remote add</h4><pre><code class="shell">$ hub remote add junoni
</code></pre>
<p>等同于</p>
<pre><code class="shell">$ git remote add junoni git://github.com/junoni/nimon.git
</code></pre>
<h4 id="hub-fetch"><a href="#hub-fetch" class="headerlink" title="hub fetch"></a>hub fetch</h4><p>类似于 <code>hub remote add</code></p>
<h4 id="hub-cherry-pick"><a href="#hub-cherry-pick" class="headerlink" title="hub cherry-pick"></a>hub cherry-pick</h4><p><code>hub cherry-pick</code> 只需要输入 URL 就可以获取对应的修改并应用到当前分支。</p>
<pre><code class="Shell">$ hub cherry-pick https://github.com/SimpleLifee/SimpleLifee.github.io/commit/647c558f5b3767c2995dda5ddd5663d0466ed4dd
</code></pre>
<p>这个命令可以将下面两个命令的效果一次性执行</p>
<pre><code class="Shell">$ git remote add -f SimpleLifee git@github.com:SimpleLifee/SimpleLifee.github.io.git
$ git cherry-pick 647c558f5b3767c2995dda5ddd5663d0466ed4dd
</code></pre>
<h4 id="hub-fork"><a href="#hub-fork" class="headerlink" title="hub fork"></a>hub fork</h4><p><code>hub fork</code> 命令的功能与 GitHub 页面的 Fork 按钮相同，比如我们 clone 了其他用户的仓库，现在想 Fork 成自己的仓库，只需要执行</p>
<pre><code class="shell">$ hub fork
</code></pre>
<p>这一命令，就可获得与下面这一系列操作相同的效果</p>
<pre><code class="shell">(在 GitHub 对仓库做 Fork 处理)
$ git remote add -f 用户名 git@github.com:当前操作仓库的名字.git
</code></pre>
<p>执行完毕后，Fork 出的仓库会被设置成当前本地仓库的远程仓库（以用户名为标识符）</p>
<h4 id="hub-pull-request"><a href="#hub-pull-request" class="headerlink" title="hub pull-request"></a>hub pull-request</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://osoa5juml.bkt.clouddn.com/image/site/1499949527648.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;自学 Git 的一些总结&lt;br&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://nijun.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>自己动手搭建个人博客到优化</title>
    <link href="http://nijun.me/2017/05/06/00001-Blog-2017-05-05-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%B0%E4%BC%98%E5%8C%96/"/>
    <id>http://nijun.me/2017/05/06/00001-Blog-2017-05-05-自己动手搭建个人博客到优化/</id>
    <published>2017-05-06T14:07:56.000Z</published>
    <updated>2017-07-13T15:23:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://osoa5juml.bkt.clouddn.com/avatar.jpg" alt=""></p>
 <div align="center"><br>  今天，是你未来所有剩余的日子中，最早的一天<br><br></div>

<div align="right">——<strong>stormzhang</strong>      </div>







<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><br></p>
<p>我为什么要写这篇文章？是因为大学三年了，感觉学了这么多知识，但是并没有真正地去消化和总结过，最近又看到了<a href="http://www.baidu.com" title="stormzhang" target="_blank" rel="external">stormzhang</a>大神写的这篇<a href="http://stormzhang.com/android/2016/03/04/why-i-keep-writing-blog/" title="stormzhang" target="_blank" rel="external">我为什么坚持写博客？</a>。我真的感触很深，以前花了很多时间学的东西，不久之后便会印象模糊，想要回忆的时候，又不能快速找到。所以我决定从今天开始写博客，总结和梳理自己的知识。</p>
<a id="more"></a>
<p>stormzhang在他的文章里推荐了hexo，基于Node框架，可以和Github Pages结合起来搭建个人博客。而且主题样式非常多，可以自己选择搭配的东西很多。当我第一次把博客跑起来的时候，真的惊呆了，没想到个人博客也可以这么轻松的搭建。我用了五一这个假期，自己动手搭建了现在您正看到的这个博客，虽然现在很粗糙，但是我会不断的学习和优化它的。</p>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h3><p>Hexo是一个快速，简单和强大的博客框架。可以使用Markdown进行写作，Hexo会在几秒钟内生成具有美丽主题的静态文件。</p>
<h3 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h3><p>这里具体的操作步骤可以到<a href="https://hexo.io/" target="_blank" rel="external">hexo官网</a>。</p>
<ul>
<li><a href="https://nodejs.org" target="_blank" rel="external">Node.js</a></li>
<li><a href="https://git-scm.com/" target="_blank" rel="external">Git</a></li>
</ul>
<p>如果已经装好了这些，那么我们现在就开始吧！</p>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>一旦安装了所有要求，可以用npm安装Hexo。</p>
<pre><code class="shell">$ npm install hexo-cli -g  //在本地安装hexo的环境
</code></pre>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>首先选择一个目录作为hexo博客的根目录，使用git bash cd到这个目录，然后输入  </p>
<pre><code class="shell">$ hexo init &lt;folder&gt;   //推荐 ，这里的folder参数如果指定，便会在终端当前的资料夹建立一个名为 folder 的新资料夹；
$ hexo init  //直接使用当前目录初始化
</code></pre>
<p>完成后</p>
<pre><code class="shell">   $ cd folder
   $ npm install  //在当前目录下安装hexo核心文件
   $ npm install hexo --no-optional --save
</code></pre>
<p>这样就安装完成了。这时候可以看到<code>floder</code>文件夹下具有这些子目录</p>
<pre><code class="Yaml">    .
    ├── _config.yml   站点配置文件
    ├── package.json
    ├── scaffolds    存放模板的地方
    ├── source       原文件夹，存放网站内容
    |   ├── _drafts  存放临时草稿文件的地方
    |   └── _posts   已经发布的文章
    └── themes       主题文件夹
</code></pre>
<p> <code>source</code>中带有前缀_(下划线)的文件夹，在<code>generate</code>的时候会渲染到<code>public</code>目录中，其他的文件夹和文件仅仅被简单地复制到<code>public</code>中。</p>
<p>在<code>floder</code>目录下，有一个<code>_config.yml</code>，这个文件是整个网站的核心配置文件，由于后面主题文件夹中也有一个同名的配置文件，为了区分，网站的核心配置文件就叫做<code>站点配置文件</code>，主题中的叫做<code>主题配置文件</code>。</p>
<p>打开<code>站点配置文件</code>,可以看到<code>Site</code>标签，这是我的配置。</p>
<pre><code class="Yaml">    # Site
    title: SimpleLifee  #网站标题
    subtitle: code, mylife   #网站副标题
    description: start from zero     #网站描述
    author: Nimon        #你的名字
    language: zh-Hans    #语言，
    timezone: Asia/Shanghai  #时区
</code></pre>
<p>还有<code>Deployment</code>标签，与Github Pages进行关联</p>
<pre><code class="Yaml"># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
     type: git
     repo: git@github.com:SimpleLifee/SimpleLifee.github.io.git 
     branch: master
</code></pre>
<p>其中<code>type</code>必须填git，<code>repo</code>填写你在git上创建的库的<code>ssh</code>地址，或者<code>https</code>地址。<code>注意</code>如果是https的那么以后每次<code>deploy</code>的时候都要求你输入用户名和密码,如果改成<code>ssh</code>并且你没有给你的id_rsa设置密码（空密码也一样）的话，就不用每次都输入密码了。</p>
<pre><code class="java">$ ssh-keygen -p -f /root/.ssh/id_dsa -N &#39;&#39;
</code></pre>
<p>如果你之前设置了密码，那么使用这条命令就可以更改你的私钥的密码了。参考<a href="https://superuser.com/questions/508408/public-key-always-asking-for-password-and-keyphrase" target="_blank" rel="external">superuser</a></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><pre><code class="java">$ hexo new [layout] &lt;title&gt;
</code></pre>
<p>创建一个新文章，<code>layout</code>可以有三个参数<code>post</code>、<code>page</code>、<code>draft</code>, hexo 会在 <code>Scaffold</code> 文件夹下寻找你写的 <code>layout.md</code> 文件模板来建立文件。如果 <code>title</code> 包含空格，请用引号括起来。</p>
<h4 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h4><p>在站点配置文件中<code>Writing</code> 标签下添加</p>
<pre><code class="Yaml">new_post_name: :year-:month-:day-:title.md
</code></pre>
<p>其中 <code>:month</code> 和 <code>:i_month</code> 的区别在于 前者有前导零 （比如 <code>04</code> ）</p>
<h4 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h4><p>如果创建新文章的时候，指定了 <code>draft</code> 参数，那么就是保存到 <code>source/_drafts</code> 文件夹中，可以使用下面的语句，将草稿移动到 <code>source/_posts</code>文件中。</p>
<pre><code class="java">$ hexo publish [layout] &lt;filename&gt;
</code></pre>
<p>发布草稿变成正式文章。一般<code>filename</code>写你的草稿文件的名字，<code>layout</code>写<code>post</code></p>
<h4 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h4><p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：</p>
<pre><code class="java">$ hexo new photo &quot;My Gallery&quot;
</code></pre>
<p>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>layout</code></td>
<td>布局</td>
</tr>
<tr>
<td><code>title</code></td>
<td>标题</td>
</tr>
<tr>
<td><code>date</code></td>
<td>文件建立日期</td>
</tr>
</tbody>
</table>
<h3 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code>、<code>draft</code>，它们分别对应不同的路径，自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p>
<table>
<thead>
<tr>
<th style="text-align:left">布局</th>
<th style="text-align:left">路径</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">post</td>
<td style="text-align:left">source/_posts</td>
</tr>
<tr>
<td style="text-align:left">page</td>
<td style="text-align:left">source</td>
</tr>
<tr>
<td style="text-align:left">draft</td>
<td style="text-align:left">source/_drafts</td>
</tr>
</tbody>
</table>
<blockquote>
<p>不要处理我的文章<br>可以在Front-Matter 中的layout: 设为 false。</p>
</blockquote>
<h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p>Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，例如</p>
<pre><code>title: Hello World
date: 2017/5/1 20:46:25
---
</code></pre><p>也可以使用JSON 格式，只需要把 — 换成 ;;;</p>
<pre><code>&quot;title&quot;: &quot;Hello World&quot;,
&quot;date&quot;: &quot;2017/5/1 20:46:25&quot;
;;;
</code></pre><p>Front-matter的参数列表</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>layout</code></td>
<td>布局</td>
<td></td>
</tr>
<tr>
<td><code>title</code></td>
<td>标题</td>
<td></td>
</tr>
<tr>
<td><code>date</code></td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr>
<td><code>updated</code></td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr>
<td><code>comments</code></td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr>
<td><code>description</code></td>
<td>文章的描述</td>
<td></td>
</tr>
<tr>
<td><code>tags</code></td>
<td>标签（不适用于分页）</td>
<td></td>
</tr>
<tr>
<td><code>categories</code></td>
<td>分类（不适用于分页）</td>
<td></td>
</tr>
<tr>
<td><code>permalink</code></td>
<td>覆盖文章网址</td>
</tr>
</tbody>
</table>
<h4 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h4><pre><code class="Yaml">tags:
  - List
  - Dictionary
  - ArraryList
  - hashtable
  - Stack
  - Queue
</code></pre>
<p>或者</p>
<pre><code class="Yaml"> tags:
 [Python, Javascript, Hexo]
</code></pre>
<h4 id="引用块（Block-Quote）"><a href="#引用块（Block-Quote）" class="headerlink" title="引用块（Block Quote）"></a>引用块（Block Quote）</h4><p>模板如下</p>
<pre><code>{% blockquote [author[, source]] [link] [source_link_title] %}
content
{% endblockquote %}
</code></pre><p>例如</p>
<pre><code>{% blockquote stormzhang %}
今天，是你未来所有剩余的日子中，最早的一天
{% endblockquote %}
</code></pre><blockquote><p>今天，是你未来所有剩余的日子中，最早的一天</p>
<footer><strong>stormzhang</strong></footer></blockquote>
<h4 id="代码块（Code-Block）"><a href="#代码块（Code-Block）" class="headerlink" title="代码块（Code Block）"></a>代码块（Code Block）</h4><p>模板如下</p>
<pre><code>{% codeblock [title] [lang:language] [url] [link text]%}
code snippet
{% endcodeblock %}
</code></pre><p>例如：</p>
<pre><code>{% codeblock  main.java lang:java  http://www.runoob.com/java/java-tutorial.html Java%}
public static void main(String []args){
}
{% endcodeblock  %}
</code></pre><pre><code>public static void main(String []args){
}</code></pre>
<h4 id="醒目引文（Pull-Quote）"><a href="#醒目引文（Pull-Quote）" class="headerlink" title="醒目引文（Pull Quote）"></a>醒目引文（Pull Quote）</h4><pre><code class="Java">{% pullquote [class] %}
something important
{% endpullquote %}
</code></pre>
<p>如下</p>
<blockquote class="pullquote [class]"><p>something important</p>
</blockquote>
<h4 id="图片（Image）"><a href="#图片（Image）" class="headerlink" title="图片（Image）"></a>图片（Image）</h4><p>有两种方式，一种是markdown格式的</p>
<pre><code>![](/images/avatar.jpg)
</code></pre><p>另一种是hexo支持的格式</p>
<pre><code>{% img [class names] /path/to/image [width] [height][title text [alt text]] %}
</code></pre><h4 id="链接（Link）"><a href="#链接（Link）" class="headerlink" title="链接（Link）"></a>链接（Link）</h4><p>在文章中插入链接，并自动给外部链接添加 target=”_blank” 属性。</p>
<pre><code>{% link text url [external] [title] %}

{% link 谷歌 http://www.google.com google %}
</code></pre><p>如<a href="http://www.google.com" title="google" target="_blank" rel="external">谷歌</a></p>
<h4 id="外部引用（Include-Code）"><a href="#外部引用（Include-Code）" class="headerlink" title="外部引用（Include Code）"></a>外部引用（Include Code）</h4><p>可以引入其他文件中的代码，例如下面语句</p>
<pre><code>{% include_code [title][lang:language] path/to/file %}
</code></pre><blockquote>
<p>hexo支持的语法还有很多，如<br><strong>jsFiddle</strong>、<strong>Gist</strong>、<strong>iframe</strong>、<strong>Youtube</strong>、<strong>Vimeo</strong>等等，有需要的建议自行查阅<a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="external">官方文档</a></p>
</blockquote>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><h4 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h4><p>要使用hexo的服务器，首先要安装</p>
<blockquote><p>npm install hexo-server –save</p>
</blockquote>
<p>安装完成后，默认在 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，无须重启服务器。</p>
<blockquote>
<p> $ hexo server -p 5000 //启动服务器， 可以简写 hexo s</p>
</blockquote>
<p>参数 <code>-p</code> 覆盖默认端口，参数 <code>-w</code> 查看文件改动<br>看到下面的信息，说明已经成功，可以查看你的博客了。<br><img src="http://i.imgur.com/qqg116z.png" alt=""></p>
<h4 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h4><p>在静态模式下，服务器只处理 public 文件夹内的文件，而不会处理文件变动，一般性用于你正在写博客的情况下。</p>
<pre><code class="java">$ hexo server -s
</code></pre>
<h3 id="生成文件-Generating"><a href="#生成文件-Generating" class="headerlink" title="生成文件(Generating)"></a>生成文件(Generating)</h3><pre><code class="java">$ hexo generate
</code></pre>
<p>生成静态文件，参数 <code>-d</code> 生成完成后部署，参数 <code>-w</code> 查看文件改动，下面两种写法都一样</p>
<pre><code class="java">$ hexo g -d
$ hexo d -g
</code></pre>
<h4 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h4><pre><code class="java">$ hexo generate --watch
</code></pre>
<p>Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。</p>
<h3 id="部署（Deployment）"><a href="#部署（Deployment）" class="headerlink" title="部署（Deployment）"></a>部署（Deployment）</h3><pre><code class="java">$ hexo deploy
</code></pre>
<p>部署你的网站，在使用之前，需要在<code>站点配置文件</code> 进行配置。可以有多个deployer</p>
<pre><code class="Yaml">deploy:
- type: git
  repo:
- type: heroku    
  repo:
</code></pre>
<blockquote>
<p>缩进</p>
<p>YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。</p>
</blockquote>
<h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p>部署提示找不到Git , 直接使用这个命令从 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external">hexo-deployer-git</a> 上安装git的部署插件</p>
<pre><code class="java">$ npm install hexo-deployer-git --save
</code></pre>
<p>修改配置。<br><pre><code>deploy:
type: git
repo: &lt;repository url&gt;  
branch: [branch]  
message: [message]</code></pre><br>​    </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>repo</code></td>
<td>库（Repository）地址</td>
</tr>
<tr>
<td><code>branch</code></td>
<td>分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。                    最好填ssh，这样就每次deploy的时候都要输入密码了。</td>
</tr>
<tr>
<td><code>message</code></td>
<td>自定义提交信息 (默认为 <code>Site updated: { { now(&#39;YYYY-MM-DD HH:mm:ss&#39;) }}</code>)</td>
</tr>
</tbody>
</table>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>其他部署方案，可以参见<a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="external">官方文档</a></p>
<pre><code class="java">$ hexo clean
</code></pre>
<p>清除缓存文件（db.json）和生成的文件（public）</p>
<pre><code class="java">$ hexo list &lt;type&gt;
</code></pre>
<p><code>type</code> 可以是<code>page</code>, <code>post</code>,<code>route</code>, <code>tag</code>, <code>category</code></p>
<pre><code class="java">$ hexo version
</code></pre>
<p>显示版本信息</p>
<pre><code class="java">$ hexo --config custom.yml
$ hexo --config custom.yml，custom2.json
</code></pre>
<p>使用自定义配置文件（而不是_config.yml），还可以接受将文件合并为一个的JSON或YAML配置文件的逗号分隔列表（无空格）</p>
<p>自动更新文件</p>
<pre><code class="java">$ hexo g     //也可以这样写hexo generate
</code></pre>
<p>部署到git</p>
<pre><code class="java">$ hexo d
</code></pre>
<p>一般可以这样简写，就是说在部署到git之前，先进行更新</p>
<pre><code class="java">$ hexo d -g
</code></pre>
<p>可以查看hexo的版本</p>
<pre><code class="java">hexo -v
</code></pre>
<p>这时候万一遇到这个错误</p>
<pre><code>ERROR Deployer not found: git
</code></pre><p>试试</p>
<pre><code class="java">$ npm install hexo-deployer-git --save
$ npm install hexo --save
</code></pre>
<p>如果是下面这个问题：</p>
<pre><code>{ [Error: Cannot find module &#39;./build/Release/DTraceProviderBindings&#39;] code: &#39;MODULE_NOT_FOUND&#39; }
{ [Error: Cannot find module &#39;./build/default/DTraceProviderBindings&#39;] code: &#39;MODULE_NOT_FOUND&#39; }
{ [Error: Cannot find module &#39;./build/Debug/DTraceProviderBindings&#39;] code: &#39;MODULE_NOT_FOUND&#39; }
</code></pre><p>那就</p>
<pre><code>npm install hexo --no-optional
</code></pre><p>#NexT</p>
<p>如果你熟悉 Git， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。</p>
<ol>
<li>下载主题</li>
</ol>
<p>​```java<br>$ cd your-hexo-site<br>$ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a> themes/next</p>
<pre><code>


2. 启用主题
   与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 `站点配置文件`， 找到` theme `字段，并将其值更改为` next`。
</code></pre><p>   theme: next</p>
<pre><code>
   到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 `$ hexo clean` 来清除 Hexo 的缓存。





### 一些好用的插件 ###

{% blockquote %}
hexo可视化后台管理，很方便 - [hexo-hey](https://github.com/nihgwu/hexo-hey)  
在 hexo 中无痛使用本地图片 - [hexo-asset-image](https://github.com/CodeFalling/hexo-asset-image)
备份整个博客包括主题 - [hexo-git-backup](https://github.com/coneycode/hexo-git-backup)


{% endblockquote %}

### 参考 ###

{% blockquote %}
网易云音乐 - [Hexo中播放网易云音乐的实践](http://weqeo.com/2016/10/11/Hexo中播放网易云音乐的实践)  
网易云音乐 - [GitHub Ribbons](https://github.com/blog/273-github-ribbons)  
字数统计WordCount 、阅读时长预计Min2Read、总字数统计TotalCount - [hexo-wordcount](https://github.com/willin/hexo-wordcount)  

{% endblockquote %}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://osoa5juml.bkt.clouddn.com/avatar.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
 &lt;div align=&quot;center&quot;&gt;&lt;br&gt;  今天，是你未来所有剩余的日子中，最早的一天&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;div align=&quot;right&quot;&gt;——&lt;strong&gt;stormzhang&lt;/strong&gt;      &lt;/div&gt;







&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;我为什么要写这篇文章？是因为大学三年了，感觉学了这么多知识，但是并没有真正地去消化和总结过，最近又看到了&lt;a href=&quot;http://www.baidu.com&quot; title=&quot;stormzhang&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stormzhang&lt;/a&gt;大神写的这篇&lt;a href=&quot;http://stormzhang.com/android/2016/03/04/why-i-keep-writing-blog/&quot; title=&quot;stormzhang&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我为什么坚持写博客？&lt;/a&gt;。我真的感触很深，以前花了很多时间学的东西，不久之后便会印象模糊，想要回忆的时候，又不能快速找到。所以我决定从今天开始写博客，总结和梳理自己的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://nijun.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://nijun.me/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>一些mac端好用端插件分享</title>
    <link href="http://nijun.me/2017/05/05/00001-Blog-2017-05-05-%E4%B8%80%E4%BA%9Bmac%E7%AB%AF%E5%A5%BD%E7%94%A8%E7%AB%AF%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
    <id>http://nijun.me/2017/05/05/00001-Blog-2017-05-05-一些mac端好用端插件分享/</id>
    <published>2017-05-05T05:28:27.000Z</published>
    <updated>2017-07-13T12:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"><br>想要生活变得更好？来看看这些插件吧！<br></div><br><img src="http://osoa5juml.bkt.clouddn.com/image/site/1499949422354.png" alt=""><br><a id="more"></a></p>
<p>[TOC]</p>
<hr>
<h1 id="百度云限速？试试Mac神器Aria2"><a href="#百度云限速？试试Mac神器Aria2" class="headerlink" title="百度云限速？试试Mac神器Aria2"></a>百度云限速？试试Mac神器Aria2</h1><p><br><br>使用Tampermonkey插件 + “百度网盘直接下载助手”脚本（2017-03-20更新）</p>
<p>在Chrome上安装Tampermonkey插件。</p>
<p>安装“百度网盘直接下载助手”脚本。</p>
<h1 id="会在百度云下载页面原来”下载”按钮旁边多出一个”下载助手”的按钮。"><a href="#会在百度云下载页面原来”下载”按钮旁边多出一个”下载助手”的按钮。" class="headerlink" title="会在百度云下载页面原来”下载”按钮旁边多出一个”下载助手”的按钮。"></a>会在百度云下载页面原来”下载”按钮旁边多出一个”下载助手”的按钮。</h1><p>点击“直接下载”会使用浏览器默认下载器进行下载。点击“显示链接”，可复制链接放入aria2进行下载。</p>
<hr>
<h1 id="添加sitemap和feed插件"><a href="#添加sitemap和feed插件" class="headerlink" title="添加sitemap和feed插件"></a>添加sitemap和feed插件</h1><p><br></p>
<p>切换到你本地的hexo，</p>
<pre><code>npm install hexo-generator-feed -save
npm install hexo-generator-sitemap -save
</code></pre><p>修改_config.yml，增加以下内容</p>
<pre><code># ExtensionsPlugins:
- hexo-generator-feed
- hexo-generator-sitemap

 #Feed Atomfeed:
  type: atom
  path: atom.xml
  limit: 20#sitemapsitemap:
  path: sitemap.xml
</code></pre><p>再执行以下命令，部署服务端<br>hexo d -g</p>
<p>配完之后，就可以访问 <a href="https://gdutxiaoxu.github.io/atom.xml" target="_blank" rel="external">https://gdutxiaoxu.github.io/atom.xml</a> 和 <a href="https://gdutxiaoxu.github.io/sitemap.xml" target="_blank" rel="external">https://gdutxiaoxu.github.io/sitemap.xml</a> ，发现这两个文件已经成功生成了。</p>
<hr>
<h1 id="制作404页面"><a href="#制作404页面" class="headerlink" title="制作404页面"></a>制作404页面</h1><p><br></p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text&#x2F;html;charset=utf-8;&quot;&#x2F;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; &#x2F;&gt;
  &lt;meta name=&quot;robots&quot; content=&quot;all&quot; &#x2F;&gt;
  &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&#x2F;&gt;
&lt;&#x2F;head&gt;
&lt;body&gt;

&lt;script type=&quot;text&#x2F;javascript&quot; src=&quot;http:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;your site url &quot; homePageName=&quot;回到我的主页&quot;&gt;&lt;&#x2F;script&gt;

&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>
<h1 id="其他一些好用的插件"><a href="#其他一些好用的插件" class="headerlink" title="其他一些好用的插件"></a>其他一些好用的插件</h1><blockquote><p>hexo可视化后台管理，很方便 - <a href="https://github.com/nihgwu/hexo-hey" target="_blank" rel="external">hexo-hey</a><br>在 hexo 中无痛使用本地图片 - <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="external">hexo-asset-image</a><br>备份整个博客包括主题 - <a href="https://github.com/coneycode/hexo-git-backup" target="_blank" rel="external">hexo-git-backup</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;想要生活变得更好？来看看这些插件吧！&lt;br&gt;&lt;/div&gt;&lt;br&gt;&lt;img src=&quot;http://osoa5juml.bkt.clouddn.com/image/site/1499949422354.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>

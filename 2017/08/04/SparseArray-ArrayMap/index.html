<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="google-site-verification" content="" />
  
  <title>Viewholder中为什么要使用SparseArray对View进行存储？</title>
  <meta name="author" content="SmartNi">
  <meta name="description" content="写出来是为了更好的理解">
  
  
  <meta property="og:title" content="Viewholder中为什么要使用SparseArray对View进行存储？"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:site_name" content="SmartNi"/>
  <link href="/apple-touch-icon-precomposed.png" sizes="180x180" rel="apple-touch-icon-precomposed">
  <link rel="alternate" href="/atom.xml" title="SmartNi" type="application/atom+xml">
  <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/m.min.css">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
</head>

<body>
  <a id="top"></a>
  <div id="main">
    <div class="behind">
      <a href="/" class="back black-color">
        <svg class="i-close" viewBox="0 0 32 32" width="22" height="22" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
            <path d="M2 30 L30 2 M30 30 L2 2"></path>
        </svg>
      </a>
      <div class="description">
        &nbsp;专注
      </div>
    </div>
    <div class="main-ctnr">
      

  <article class="standard post">
    <div class="title">
      
  
    <h1 class="page-title center">
        Viewholder中为什么要使用SparseArray对View进行存储？
    </h1>
  


    </div>
    <div class="meta center">
      
<time datetime="2017-08-04T05:59:21.000Z">
<svg class="i-calendar" viewBox="0 0 32 32" width="14" height="14" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
    <path d="M2 6 L2 30 30 30 30 6 Z M2 15 L30 15 M7 3 L7 9 M13 3 L13 9 M19 3 L19 9 M25 3 L25 9"></path>
  </svg>
  &nbsp;
  2017-08-04
</time>






    
    &nbsp;
    <svg class="i-tag" viewBox="0 0 32 32" width="14" height="14" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      <circle cx="24" cy="8" r="2"></circle>
      <path d="M2 18 L18 2 30 2 30 14 14 30 Z"></path>
    </svg>
    &nbsp;
    <a href="/tags/Android/">Android</a>


    </div>
    <hr>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Hashmap"><span class="toc-text">Hashmap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SparseArray"><span class="toc-text">SparseArray</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayMap"><span class="toc-text">ArrayMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#总结："><span class="toc-text">总结：</span></a></li></ol></li></ol></li></ol>
    <div class="picture-container">
      
    </div>
    <p>未经反思自省的人生不值得去过    The unexamined life is not worth living.    @苏格拉底 (哲学之父)</p>
<a id="more"></a>
<p>最近项目时，设计 ViewHolder 时用到了 SparseArray，为什么一定要用这个呢？ SparseArray 有什么优点吗？</p>
<p>private SparseArray<view> mViews; </view></p>
<p>使用SparseArray保存View。</p>
<p> SparseArray 比 HashMap更省内存。为什么？</p>
<p>参考：<a href="http://blog.csdn.net/u010687392/article/details/47809295" target="_blank" rel="external">http://blog.csdn.net/u010687392/article/details/47809295</a></p>
<hr>
<h1 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h1><p>Hashmap内部默认使用一个容量16的数组来存储数据，而数组中每个元素又是一个链表的头结点。也就是说，Hashmap内部是使用哈希表的拉链结构（数组+链表），也叫做拉链法：</p>
<p><img src="http://osoa5juml.bkt.clouddn.com/image/site/1501826801083.png" width="528"></p>
<p>每个结点是一个Entry，Entry的内部的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">final K key; </div><div class="line"></div><div class="line">V value; </div><div class="line"></div><div class="line">final int hash; </div><div class="line"></div><div class="line">HashMapEntry&lt;K, V&gt; next;</div></pre></td></tr></table></figure>
<p>这些Entry数据是按什么规则进行存储的？</p>
<p>通过key计算hash值，然后对HashMap中的数组长度取余得到该元素的存储位置，  hash(key) % len。</p>
<p>拉链法解决了元素冲突的问题，后一个元素不会覆盖前一个元素。</p>
<p>解决hash冲突的方法还有：</p>
<p>1、开放地址法</p>
<p>2、再哈希法</p>
<p>3、链地址法</p>
<p>4、建立公共溢出区</p>
<p>HashMap的默认容量是16，我们创建一个新的HashMap，即使里面没有数据，也会占用16个数据的内存。如果不断往里面put东西，容量到达一个值时就会扩容，这个值怎么算？  答 ：当前容量 * 加载因子（HashMap默认是0.75）。 根据源码，它一定会扩大为原来的两倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int newCapacity = oldCapacity * 2;</div></pre></td></tr></table></figure>
<p>所以说，只要满足条件就会扩容，如果数据量很大，就需要不算扩容（而且是2倍），加上计算hash值的消耗，会对内存空间造成很大的消耗和浪费。</p>
<p>HashMap是通过遍历entry[]数组来得到对应的元素，数据量一大就会比较慢。</p>
<h1 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h1><p>SparseArray能避免对key的自动装箱（比如 int 转为 Integer），内部是通过两个数组来存储数据。注意这里key只能是int类型的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private int[] mKeys; </div><div class="line"></div><div class="line">private Object[] mValues;</div></pre></td></tr></table></figure>
<p>SparseArray在读取和存放数据的时候，是使用二分查找法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void put(int key, E value) &#123;</div><div class="line">      int i = ContainerHelpers.binarySearch(mKeys, mSize, key); </div><div class="line">      … </div><div class="line">&#125; </div><div class="line">public E get(int key, E valueIfKeyNotFound) &#123;</div><div class="line">      int i = ContainerHelpers.binarySearch(mKeys, mSize, key); </div><div class="line">      … </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Put的时候会使用二分查找法，对当前添加的元素和之前已添加的元素的key进行比较，然后从小到大排序。所以SparseArray存储的元素都是按元素的key值从小到大排序好的。</p>
<p>获取的时候也使用二分查找法，比HashMap快得多，HashMap是通过遍历entry数组来获取元素的。</p>
<p>添加数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void put(int key, E value)</div></pre></td></tr></table></figure>
<p>删除数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void remove(int key)</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void delete(int key)</div></pre></td></tr></table></figure>
<p>remove内部就是调用delete来删除的。</p>
<p>获取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public E get(int key)</div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public E get(int key, E valueIfKeyNotFound)</div></pre></td></tr></table></figure></p>
<p>如果key不存在就会返回valueIfKeyNotFound。</p>
<p>特有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public int keyAt(int index)</div><div class="line"></div><div class="line">和</div><div class="line"></div><div class="line">public E valueAt(int index)</div></pre></td></tr></table></figure></p>
<p>SparseArray      应用场景<br>虽说SparseArray的性能比较好，但是由于每次增加、修改、删除都需要进行一个二分查找，所以一旦数据量大了，性能提升的并不明显，降低至少50%。</p>
<p>满足下面两个条件我们可以使用SparseArray代替HashMap：</p>
<ol>
<li>数据量不大，最好在千级以内</li>
<li>key必须为int类型</li>
</ol>
<p>这样，把HashMap替换成SparseArray比较好。</p>
<h1 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h1><p>ArrayMap是一个<key,value>映射的map数据结构，SparseArray是数组结构，基本和SparseArray一样。</key,value></p>
<p>ArrayMap应用场景</p>
<p>满足下面两个条件我们可以使用ArrayMap代替HashMap：</p>
<ul>
<li>数据量不大，最好在千级以内</li>
<li>数据结构类型为Map类型</li>
</ul>
<p>注意这个类在API 19之后才能用，若要兼容之前版本，需要导包：</p>
<p>import android.support.v4.util.ArrayMap;</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>SparseArray 和 ArrayMap 如何选择？</p>
<p>假设数据量都在千级以内的情况下：</p>
<p>1、如果key的数据类型确定为int类型，那么使用SparseArray，因为它避免了自动装箱，如果key为long，它还提供了一个LongSparseArray来确保key为long类型时的使用。</p>
<p>2、如果key类型为其它的类型，则使用ArrayMap。</p>


  </article>
  </script>
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  <div class="busuanzi center">
    page PV:&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;・&nbsp;
    site PV:&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;・&nbsp;
    site UV:&nbsp;<span id="busuanzi_value_site_uv"></span>
  </div>




    </div>
  </div>
  <footer class="page-footer"><div class="clearfix">
</div>
<div class="right-foot">
    <div class="firstrow">
        <a href="#top" target="_self">
        <svg class="i-caret-right" viewBox="0 0 32 32" width="24" height="24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
            <path d="M10 30 L26 16 10 2 Z"></path>
        </svg>
        </a>
        © XXX 20xx-2017
    </div>
    <div class="secondrow">
        <a href="https://github.com/gaoryrt/hexo-theme-pln">
        Theme Pln
        </a>
    </div>
</div>
<div class="clearfix">
</div>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<script src="/js/search.min.js"></script>
<script type="text/javascript">

// disqus scripts


// dropdown scripts
$(".dropdown").click(function(event) {
  var current = $(this);
  event.stopPropagation();
  $(current).children(".dropdown-content")[($(current).children(".dropdown-content").hasClass("open"))?'removeClass':'addClass']("open")
});
$(document).click(function(){
    $(".dropdown-content").removeClass("open");
})

var path = "/search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');

</script>

</body>
</html>

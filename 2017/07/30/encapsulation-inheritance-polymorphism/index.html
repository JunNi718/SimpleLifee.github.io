<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>温故而知新——封装继承多态 | SmartNi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="面向对象的三个基本特征是：封装、继承、多态。这是我对这三个特征的一些总结，希望能帮助大家复习一下。  什么是封装 ？封装通过合并特征和行为来创建新的数据类型，并隐藏实现细节（私有化），把接口和实现分离开来，使得代码模块化。 什么是继承 ？一句话解释就是：继承可以扩展已存在的代码模板（类）。继承和封装有一个共同的目的——代码重用。 除了修饰为 private 和 final 的，子类是继承不了的">
<meta property="og:type" content="article">
<meta property="og:title" content="温故而知新——封装继承多态">
<meta property="og:url" content="http://nijun.me/2017/07/30/encapsulation-inheritance-polymorphism/index.html">
<meta property="og:site_name" content="SmartNi">
<meta property="og:description" content="面向对象的三个基本特征是：封装、继承、多态。这是我对这三个特征的一些总结，希望能帮助大家复习一下。  什么是封装 ？封装通过合并特征和行为来创建新的数据类型，并隐藏实现细节（私有化），把接口和实现分离开来，使得代码模块化。 什么是继承 ？一句话解释就是：继承可以扩展已存在的代码模板（类）。继承和封装有一个共同的目的——代码重用。 除了修饰为 private 和 final 的，子类是继承不了的">
<meta property="og:image" content="https://mmbiz.qlogo.cn/mmbiz_jpg/cOpSHfR7OBp9wokabGvc5BEdicoQ2hI8nZibyaTyYPReLg9fwmO5ce4ibR1fBTFgVaoOGiar3eSIa8VXMSoibRYzpcw/0.jpeg">
<meta property="og:image" content="https://mmbiz.qlogo.cn/mmbiz/cZV2hRpuAPjEIibB1UYw1VMPzscNxReKZVxEh23qB9KgPqFq3uoyBy3M93PcFOunrvjkYVrtfvXMworbBuWAZ4A/0">
<meta property="og:image" content="https://mmbiz.qlogo.cn/mmbiz_jpg/cOpSHfR7OBp9wokabGvc5BEdicoQ2hI8nQ2VylH1opRxHc5XAkvrTf4nS4KoZC14SRgh0vkHLIM7icicHlDwD8gQA/0.jpeg">
<meta property="og:updated_time" content="2017-08-04T12:44:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="温故而知新——封装继承多态">
<meta name="twitter:description" content="面向对象的三个基本特征是：封装、继承、多态。这是我对这三个特征的一些总结，希望能帮助大家复习一下。  什么是封装 ？封装通过合并特征和行为来创建新的数据类型，并隐藏实现细节（私有化），把接口和实现分离开来，使得代码模块化。 什么是继承 ？一句话解释就是：继承可以扩展已存在的代码模板（类）。继承和封装有一个共同的目的——代码重用。 除了修饰为 private 和 final 的，子类是继承不了的">
<meta name="twitter:image" content="https://mmbiz.qlogo.cn/mmbiz_jpg/cOpSHfR7OBp9wokabGvc5BEdicoQ2hI8nZibyaTyYPReLg9fwmO5ce4ibR1fBTFgVaoOGiar3eSIa8VXMSoibRYzpcw/0.jpeg">
  
    <link rel="alternate" href="/atom.xml" title="SmartNi" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/squirrel.png">
  
  <link rel="stylesheet" href="/css/typing.css">
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-encapsulation-inheritance-polymorphism" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/">
        Home
      </a>
      
      <a class="main-nav-link" href="/archives">
        Archives
      </a>
      
      <a class="main-nav-link" href="/programming">
        Programming
      </a>
      
      <a class="main-nav-link" href="/categories">
        Categories
      </a>
      
      <a class="main-nav-link" href="/about">
        About
      </a>
      
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
      
      <br/>
      <p id="text"> </p>
      <div class="descriptionwrapper">
      <p class="description"> </p>
      </div>
  </nav>
</header>
  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      温故而知新——封装继承多态
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <p><img src="https://mmbiz.qlogo.cn/mmbiz_jpg/cOpSHfR7OBp9wokabGvc5BEdicoQ2hI8nZibyaTyYPReLg9fwmO5ce4ibR1fBTFgVaoOGiar3eSIa8VXMSoibRYzpcw/0.jpeg" alt="img"></p>
<blockquote>
<p>面向对象的三个基本特征是：封装、继承、多态。这是我对这三个特征的一些总结，希望能帮助大家复习一下。</p>
</blockquote>
<h1 id="什么是封装-？"><a href="#什么是封装-？" class="headerlink" title="什么是封装 ？"></a>什么是封装 ？</h1><p>封装通过合并特征和行为来创建新的数据类型，并隐藏实现细节（私有化），把接口和实现分离开来，使得代码模块化。</p>
<h1 id="什么是继承-？"><a href="#什么是继承-？" class="headerlink" title="什么是继承 ？"></a>什么是继承 ？</h1><p>一句话解释就是：继承可以扩展已存在的代码模板（类）。继承和封装有一个共同的目的——代码重用。</p>
<p>除了修饰为 private 和 final 的，子类是继承不了的之外，构造器也是不能被继承的。对于构造器而言，它只能够被调用（ super() ），而不能被继承。</p>
<p>子类会默认调用父类的构造器。如果父类没有默认的构造器，子类必须显示地指定父类的构造器，而且必须是在子类构造器中做的第一件事（第一行代码）。</p>
<p>要实现继承，可以通过 “ 继承 ” 或 “ 组合 ” 来实现。</p>
<p>继承是一种强耦合关系，当考虑要不要继承的时候，先问自己子类是否需要向上转型到父类。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑是否需要继承。</p>
<p>继承允许将对象视为自己本身的类型或其基类型来加以处理（ 向上转型 ）。也就是说继承允许将多种类型（ 同一父类导出的 ）视为同一类型来处理。这为多态提供了前提条件。接下来我们来看看多态。</p>
<h1 id="什么是多态-？"><a href="#什么是多态-？" class="headerlink" title="什么是多态 ？"></a>什么是多态 ？</h1><blockquote>
<p>“不要犯傻，如果它不是后期绑定，它就不是多态。” ——Bruce Eckel</p>
</blockquote>
<p>多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开来。多态的作用是消除类型之间的耦合关系。多态的目的——接口重用。</p>
<p>多态的实现条件？</p>
<p>✔继承/接口✔重写✔向上转型</p>
<p>在继承的基础上，多态允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一基类导出的。通过对同一个基类方法的调用，表现出不同的行为。</p>
<p>例如，Shape 类有三个具体子类 Circle、Square、Triangle。他们都具体实现了父类的 draw() 方法。将其中一个子类对象的引用传递给父类对象（ 这里会发生向上转型 ），调用父类对象的 draw() 方法，就会表现出子类对象的具体行为。这是多么的神奇啊！</p>
<p>继承是单继承，接口是多继承多实现。实际上，接口与多态有更广泛的应用。</p>
<p>为什么重载不行？</p>
<p>方法重载其实不属于 “ 面向对象编程 ”，重载的实现是：编译器根据函数不同的参数列表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（ 至少对于编译器来说是这样的 ）。也就是说，重载的方法的地址在编译器就绑定了（ 前期绑定 ），因此，重载与多态无关。</p>
<p>真正和多态相关的是 “ 覆盖 ” ，也就是方法重写。当子类重新定义父类的函数后，子类将自己的类型传递给父类后，父类动态调用属于子类的该函数，这样的函数调用再编译器是无法确定的（ 调用子类的的函数地址无法给出 ）。因此，这样的函数地址是在运行期绑定的。</p>
<p>需要注意的是，private 和 final 方法是不能被覆盖的。private 方法被自动认为是 final 方法。</p>
<p>这里还有一个大坑，那就是域和静态方法。我们来看一个例子</p>
<pre><code class="java">class Super{
  public int field = 0;
  public int getField() { return field; }
}
</code></pre>
<pre><code class="java">class Sub extends Super{
    public int field = 1;
      public int getField() { return field; }
      public int getSuperField() { return super.field; }
}
</code></pre>
<pre><code class="java">public class FieldAccess{
  public static void main(String[] args){
    Super sup = new Sub(); //向上转型
    System.out.println(&quot;sup.field = &quot; + sup.field +
        &quot;, sup.getField() = &quot; + sup.getFiled());
    Sub sub = new Sub(); 
    System.out.println(&quot;sub.field = &quot; + sub.field +
        &quot;, sub.getField() = &quot; + sub.getFiled() +
        &quot;, sub.getSuperField() = &quot; + sub.getSuperField());
  }
}
</code></pre>
<p>结果是</p>
<blockquote>
<p>sup.field = 0,sup.getField() = 1</p>
<p>sub.field = 1,sub.getField() = 1,sub.getSuperField() = 0</p>
</blockquote>
<p>可以看到 sup.field 等于 0 ，也就是说，并没有显示出子类的具体特征。</p>
<p>当子类对象转型为父类引用时，任何域的访问操作都将由编译器解析。由编译器解析就不是多态，因为它是前期绑定。在这个例子中，为 Super.field 和 Sub.field 分配了不同的存储空间，这样 Sub 就包含了两个称为 field 的域：它自己的和从 Super 继承得到的，最重要的是在引用 Sub 中的 field 时所产生的默认域并非 Super 的，要想获取 Super.field 就必须显式地指明 super.field。</p>
<p><img src="https://mmbiz.qlogo.cn/mmbiz/cZV2hRpuAPjEIibB1UYw1VMPzscNxReKZVxEh23qB9KgPqFq3uoyBy3M93PcFOunrvjkYVrtfvXMworbBuWAZ4A/0" alt="金属质感分割线"></p>
<p>注：方法调用绑定（Method-call binding）</p>
<p>下面是 《Think in Java》中对绑定的解释:</p>
<p>Connecting a method call to a method body is called binding. when binding is performed before the program is run (by the compiler and linker,if there is one), it’s called early binding. </p>
<p>将一个方法调用同一个方法主体关联起来称为绑定。在程序执行前进行绑定（一般由编译器和连接程序实现），就叫做前期绑定（也可以说成是编译期绑定）。C 语言只有一种方法调用，那就是前期绑定。</p>
<p>相信小伙伴们一定猜到有前期绑定，就一定有后期绑定。没错，Java 中的后期绑定就是在运行时根据对象的类型进行绑定，后期绑定也叫做动态绑定或运行时绑定。 Java 中除了static 方法和 final 方法（ private 属于 final 方法 ） ，其他方法都是后期绑定。</p>
<center><br>END<br><img src="https://mmbiz.qlogo.cn/mmbiz_jpg/cOpSHfR7OBp9wokabGvc5BEdicoQ2hI8nQ2VylH1opRxHc5XAkvrTf4nS4KoZC14SRgh0vkHLIM7icicHlDwD8gQA/0.jpeg" alt="img"><br>长按二维码关注<br>个人博客：<a href="http://nijun.github.io" target="_blank" rel="external">http://nijun.github.io</a><br>GitHub：<a href="https://github.com/SmartNJ" target="_blank" rel="external">https://github.com/SmartNJ</a><br></center>



      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2017/07/30/encapsulation-inheritance-polymorphism/" class="article-date">
  <time datetime="2017-07-30T06:34:25.000Z" itemprop="datePublished">2017-07-30</time>
</a>

        </li>
        
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2017/08/02/overriding-overloading/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          说说 OverLoading（ 重载 ）和 Overriding（ 重写 ）的区别 ？
        
      </div>
    </a>
  
  
    <a href="/2017/07/19/gradle-plugin/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">Android 中 gradle 和 plugin 到底是什么关系？</div>
    </a>
  
</nav>


  
</article>




      </div>
      
    <footer id="footer" class="post-footer footer">
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>It’s not about making one choice and being done with it. It’s about continuous learning and sometimes, bold choices.</p>


      </div>
    </footer>

      

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-102765380-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->





    </div>
  </body>
</html>

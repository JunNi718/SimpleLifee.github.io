<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="google-site-verification" content="" />
  
  <title>温故而知新——封装继承多态</title>
  <meta name="author" content="SmartNi">
  <meta name="description" content="写出来是为了更好的理解">
  
  
  <meta property="og:title" content="温故而知新——封装继承多态"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:site_name" content="SmartNi"/>
  <link href="/apple-touch-icon-precomposed.png" sizes="180x180" rel="apple-touch-icon-precomposed">
  <link rel="alternate" href="/atom.xml" title="SmartNi" type="application/atom+xml">
  <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/m.min.css">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
</head>

<body>
  <a id="top"></a>
  <div id="main">
    <div class="behind">
      <a href="/" class="back black-color">
        <svg class="i-close" viewBox="0 0 32 32" width="22" height="22" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
            <path d="M2 30 L30 2 M30 30 L2 2"></path>
        </svg>
      </a>
      <div class="description">
        &nbsp;专注
      </div>
    </div>
    <div class="main-ctnr">
      

  <article class="standard post">
    <div class="title">
      
  
    <h1 class="page-title center">
        温故而知新——封装继承多态
    </h1>
  


    </div>
    <div class="meta center">
      
<time datetime="2017-07-30T06:34:25.000Z">
<svg class="i-calendar" viewBox="0 0 32 32" width="14" height="14" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
    <path d="M2 6 L2 30 30 30 30 6 Z M2 15 L30 15 M7 3 L7 9 M13 3 L13 9 M19 3 L19 9 M25 3 L25 9"></path>
  </svg>
  &nbsp;
  2017-07-30
</time>






    
    &nbsp;
    <svg class="i-tag" viewBox="0 0 32 32" width="14" height="14" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      <circle cx="24" cy="8" r="2"></circle>
      <path d="M2 18 L18 2 30 2 30 14 14 30 Z"></path>
    </svg>
    &nbsp;
    <a href="/tags/Java/">Java</a>


    </div>
    <hr>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是封装-？"><span class="toc-text">什么是封装 ？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是继承-？"><span class="toc-text">什么是继承 ？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是多态-？"><span class="toc-text">什么是多态 ？</span></a></li></ol>
    <div class="picture-container">
      
    </div>
    <p>想得到你从未拥有过的东西，就必须做你从未做过的事情。   @(美)Thomas Jefferson</p>
<a id="more"></a>
<blockquote>
<p>面向对象的三个基本特征是：封装、继承、多态。这是我对这三个特征的一些总结，希望能帮助大家复习一下。</p>
</blockquote>
<h1 id="什么是封装-？"><a href="#什么是封装-？" class="headerlink" title="什么是封装 ？"></a>什么是封装 ？</h1><p>封装通过合并特征和行为来创建新的数据类型，并隐藏实现细节（私有化），把接口和实现分离开来，使得代码模块化。</p>
<h1 id="什么是继承-？"><a href="#什么是继承-？" class="headerlink" title="什么是继承 ？"></a>什么是继承 ？</h1><p>一句话解释就是：继承可以扩展已存在的代码模板（类）。继承和封装有一个共同的目的——代码重用。</p>
<p>除了修饰为 private 和 final 的，子类是继承不了的之外，构造器也是不能被继承的。对于构造器而言，它只能够被调用（ super() ），而不能被继承。</p>
<p>子类会默认调用父类的构造器。如果父类没有默认的构造器，子类必须显示地指定父类的构造器，而且必须是在子类构造器中做的第一件事（第一行代码）。</p>
<p>要实现继承，可以通过 “ 继承 ” 或 “ 组合 ” 来实现。</p>
<p>继承是一种强耦合关系，当考虑要不要继承的时候，先问自己子类是否需要向上转型到父类。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑是否需要继承。</p>
<p>继承允许将对象视为自己本身的类型或其基类型来加以处理（ 向上转型 ）。也就是说继承允许将多种类型（ 同一父类导出的 ）视为同一类型来处理。这为多态提供了前提条件。接下来我们来看看多态。</p>
<h1 id="什么是多态-？"><a href="#什么是多态-？" class="headerlink" title="什么是多态 ？"></a>什么是多态 ？</h1><blockquote>
<p>“不要犯傻，如果它不是后期绑定，它就不是多态。” ——Bruce Eckel</p>
</blockquote>
<p>多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开来。多态的作用是消除类型之间的耦合关系。多态的目的——接口重用。</p>
<p>多态的实现条件？</p>
<p>✔继承/接口✔重写✔向上转型</p>
<p>在继承的基础上，多态允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一基类导出的。通过对同一个基类方法的调用，表现出不同的行为。</p>
<p>例如，Shape 类有三个具体子类 Circle、Square、Triangle。他们都具体实现了父类的 draw() 方法。将其中一个子类对象的引用传递给父类对象（ 这里会发生向上转型 ），调用父类对象的 draw() 方法，就会表现出子类对象的具体行为。这是多么的神奇啊！</p>
<p>继承是单继承，接口是多继承多实现。实际上，接口与多态有更广泛的应用。</p>
<p>为什么重载不行？</p>
<p>方法重载其实不属于 “ 面向对象编程 ”，重载的实现是：编译器根据函数不同的参数列表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（ 至少对于编译器来说是这样的 ）。也就是说，重载的方法的地址在编译器就绑定了（ 前期绑定 ），因此，重载与多态无关。</p>
<p>真正和多态相关的是 “ 覆盖 ” ，也就是方法重写。当子类重新定义父类的函数后，子类将自己的类型传递给父类后，父类动态调用属于子类的该函数，这样的函数调用再编译器是无法确定的（ 调用子类的的函数地址无法给出 ）。因此，这样的函数地址是在运行期绑定的。</p>
<p>需要注意的是，private 和 final 方法是不能被覆盖的。private 方法被自动认为是 final 方法。</p>
<p>这里还有一个大坑，那就是域和静态方法。我们来看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> field; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">1</span>;</div><div class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> field; &#125;</div><div class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSuperField</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">super</span>.field; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldAccess</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Super sup = <span class="keyword">new</span> Sub(); <span class="comment">//向上转型</span></div><div class="line">    System.out.println(<span class="string">"sup.field = "</span> + sup.field +</div><div class="line">    	<span class="string">", sup.getField() = "</span> + sup.getFiled());</div><div class="line">    Sub sub = <span class="keyword">new</span> Sub(); </div><div class="line">    System.out.println(<span class="string">"sub.field = "</span> + sub.field +</div><div class="line">    	<span class="string">", sub.getField() = "</span> + sub.getFiled() +</div><div class="line">    	<span class="string">", sub.getSuperField() = "</span> + sub.getSuperField());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果是</p>
<blockquote>
<p>sup.field = 0,sup.getField() = 1</p>
<p>sub.field = 1,sub.getField() = 1,sub.getSuperField() = 0</p>
</blockquote>
<p>可以看到 sup.field 等于 0 ，也就是说，并没有显示出子类的具体特征。</p>
<p>当子类对象转型为父类引用时，任何域的访问操作都将由编译器解析。由编译器解析就不是多态，因为它是前期绑定。在这个例子中，为 Super.field 和 Sub.field 分配了不同的存储空间，这样 Sub 就包含了两个称为 field 的域：它自己的和从 Super 继承得到的，最重要的是在引用 Sub 中的 field 时所产生的默认域并非 Super 的，要想获取 Super.field 就必须显式地指明 super.field。</p>
<p><img src="https://mmbiz.qlogo.cn/mmbiz/cZV2hRpuAPjEIibB1UYw1VMPzscNxReKZVxEh23qB9KgPqFq3uoyBy3M93PcFOunrvjkYVrtfvXMworbBuWAZ4A/0" alt="金属质感分割线"></p>
<p>注：方法调用绑定（Method-call binding）</p>
<p>下面是 《Think in Java》中对绑定的解释:</p>
<p>Connecting a method call to a method body is called binding. when binding is performed before the program is run (by the compiler and linker,if there is one), it’s called early binding. </p>
<p>将一个方法调用同一个方法主体关联起来称为绑定。在程序执行前进行绑定（一般由编译器和连接程序实现），就叫做前期绑定（也可以说成是编译期绑定）。C 语言只有一种方法调用，那就是前期绑定。</p>
<p>相信小伙伴们一定猜到有前期绑定，就一定有后期绑定。没错，Java 中的后期绑定就是在运行时根据对象的类型进行绑定，后期绑定也叫做动态绑定或运行时绑定。 Java 中除了static 方法和 final 方法（ private 属于 final 方法 ） ，其他方法都是后期绑定。</p>


  </article>
  </script>
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  <div class="busuanzi center">
    页阅读量:&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;・&nbsp;
    站访问量:&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;・&nbsp;
    站访客数:&nbsp;<span id="busuanzi_value_site_uv"></span>
  </div>




    </div>
  </div>
  <footer class="page-footer"><div class="clearfix">
</div>
<div class="right-foot">
    <div class="firstrow">
        <a href="#top" target="_self">
        <svg class="i-caret-right" viewBox="0 0 32 32" width="24" height="24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
            <path d="M10 30 L26 16 10 2 Z"></path>
        </svg>
        </a>
        © XXX 20xx-2017
    </div>
    <div class="secondrow">
        <a href="https://github.com/gaoryrt/hexo-theme-pln">
        Theme Pln
        </a>
    </div>
</div>
<div class="clearfix">
</div>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<script src="/js/search.min.js"></script>
<script type="text/javascript">

// disqus scripts


// dropdown scripts
$(".dropdown").click(function(event) {
  var current = $(this);
  event.stopPropagation();
  $(current).children(".dropdown-content")[($(current).children(".dropdown-content").hasClass("open"))?'removeClass':'addClass']("open")
});
$(document).click(function(){
    $(".dropdown-content").removeClass("open");
})

var path = "/search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');

</script>

</body>
</html>
